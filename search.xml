<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《鸣潮》基于虚幻引擎4的多平台效果和性能优化实践</title>
      <link href="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
      <url>/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="《鸣潮》基于虚幻引擎4的多平台效果和性能优化实践"><a href="#《鸣潮》基于虚幻引擎4的多平台效果和性能优化实践" class="headerlink" title="《鸣潮》基于虚幻引擎4的多平台效果和性能优化实践"></a>《鸣潮》基于虚幻引擎4的多平台效果和性能优化实践</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今年的UOD分享录播在陆续放出，考虑到学习以及归档的必要，开一个简单的小专栏来记录下自己的学习吧。</p><p><a href="https://www.bilibili.com/video/BV1BK411v7FY/?spm_id_from=333.788&amp;vd_source=ea6df38502a795b7533aa33b78bf1159">[UFSH2023]《鸣潮》基于虚幻引擎4的多平台效果和性能优化实践 | 王宏波 库洛游戏_哔哩哔哩_bilibili</a></p><p>首先是鸣潮今年的分享吧，主讲人是王宏波老师，之前我也看过他在Unreal Circle里面对于PureTS的优化分享，讲的也非常的好。</p><h2 id="为什么使用Defer-Shading"><a href="#为什么使用Defer-Shading" class="headerlink" title="为什么使用Defer Shading"></a>为什么使用Defer Shading</h2><ul><li>性能考虑 (应该是从Shader变体，光照计算等角度分析之后的结论)</li><li>方便做一些后处理效果 (例如GTAO, SSR)</li><li>统一多平台，毕竟桌面端肯定是延迟管线</li></ul><h2 id="AA做法"><a href="#AA做法" class="headerlink" title="AA做法"></a>AA做法</h2><p>首先王宏波老师说了下根据去年UOD的统计数据，NPR游戏对屏幕空间的边缘像素占比会到4%-5%，而传统PBR游戏一般会在1%~2%，所以AA这方面会成为卡渲质量的一个重要技术点。</p><p>下图是他们所分享的自研TAA流程。</p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled.png" alt="Untitled"></p><p>这里是额外加了一个Velocity的Pass并且从<strong>TAA</strong>变到的<strong>TAAU</strong>，即多了一个UpSample的过程，这里同时还说了一个我比较感兴趣的点，作者讲到TAA Pass的放置顺序问题，放在Bloom以及Tonemapping之后可能会导致边缘噪声放大。</p><h3 id="Ghost的处理方式"><a href="#Ghost的处理方式" class="headerlink" title="Ghost的处理方式"></a>Ghost的处理方式</h3><p>Ghost的处理方式如下，是一个中规中矩，首先为性能考虑的一个方案。</p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%201.png" alt="Untitled"></p><p>而角色的Ghost处理方式则较为特殊，其实应该说带动画的都需要一些特殊的处理方式，因为本身他们在屏幕空间的运动并不是完全因为相机移动而造成的。 </p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%202.png" alt="Untitled"></p><p>解决方式的话是单独的为角色开一个VelocityBuffer，然后进行对应的TAA计算，但是这么做又有一个问题，因为勾边的Pass没有对应的反应到Velocity的角色Mask中，所以会导致VelocityBuffer中角色上会有些黑线，但出于性能考虑，最后还是没有做勾边的VelocityBuffer的渲染。</p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%203.png" alt="Untitled"></p><p>总结下来就是</p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%204.png" alt="Untitled"></p><h3 id="动静像素的混合方式"><a href="#动静像素的混合方式" class="headerlink" title="动静像素的混合方式"></a>动静像素的混合方式</h3><p>动静像素混合，物体运动越快，当前帧的的权重就会升高。</p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%205.png" alt="Untitled"></p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%206.png" alt="Untitled"></p><h3 id="UpSample部分"><a href="#UpSample部分" class="headerlink" title="UpSample部分"></a>UpSample部分</h3><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%207.png" alt="Untitled"></p><h2 id="3-One-Pass-Defer"><a href="#3-One-Pass-Defer" class="headerlink" title="3. One Pass Defer"></a>3. One Pass Defer</h2><p>管线整体简介如下，也是比较经典的基于OnChip Memory的优化实现，鸣潮也是PBR和NPR结合的实现，角色和植被NPR，其它部分是PBR。</p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%208.png" alt="Untitled"></p><p>延迟管线的Gbuffer分布</p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%209.png" alt="Untitled"></p><p>这里有个坑是用了Depth Fetch之后，Mali的FPK（Early-Z）会失效。导致渲染压力显著上升。</p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%2010.png" alt="Untitled"></p><p>然后又由于Mali的PLS只有128bit，所以最后的管线变成了一条混合管线，Toon Shading走单独的一条前向渲染，这样Gbuffer就可以不存卡渲相关的信息了。</p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%2011.png" alt="Untitled"></p><p>然后最关键的一个优化，也就是卡渲的这条ForwardPass到底要插入到哪个位置比较好，一种考量是打断One Pass Defer，在Transparency后面走这条前向卡渲。</p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%2012.png" alt="Untitled"></p><p>然后显然这样等同于前面的优化工作全部白干，所以最后的方案是大改渲染（原文中说到几乎等同于重写），把这条卡通管线整合到One Pass Defer里面了，可惜宏波老师说因为时间原因，就不细细分享了。</p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%2013.png" alt="Untitled"></p><p>UE4.26以及4.27的RHI小Bug，当触发discard命令没有对GBuffer进行处理，导致Gbuffer还是在被写入。</p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%2014.png" alt="Untitled"></p><p>下图是修改后的代码</p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%2015.png" alt="Untitled"></p><p>最后是One Pass Defer和Multi Pass的性能对比，读的带宽下降了非常多，写的带宽也略有下降，分析说是移动设备对于RT的压缩很好，所以写入的时候没有那么明显的优势。</p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%2016.png" alt="Untitled"></p><h2 id="树的多端适配"><a href="#树的多端适配" class="headerlink" title="树的多端适配"></a>树的多端适配</h2><p>上来先分享了下总体的适配方案指南</p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%2017.png" alt="Untitled"></p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%2018.png" alt="Untitled"></p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%2019.png" alt="Untitled"></p><p>然后Billboard不是会跟着相机动嘛，所以渲染Shadow的时候要注意下，在写入ShadowMask的时候记得让它固定面向光源hh，不然你就会看到树木的阴影会跟着你相机移动和来回抽搐了。</p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%2020.png" alt="Untitled"></p><p>这里宏波老师说到很多人觉得Imposter和Billboard是一个东西，但是实际上Billboard和Imposter没什么关系，Imposter是用一圈相机围绕对应物体，然后离线记录对应的一些材质信息(类似于Mini Gbuffer)，然后在运行时进行重建，而Billboard就是单纯调整面片使其始终对着角色相机。</p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%2021.png" alt="Untitled"></p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%2022.png" alt="Untitled"></p><p>Imposter树也是支持Streaming的。</p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%2023.png" alt="Untitled"></p><p>性能分析，4个DrawCall就可以画出一大堆Imposter树木，以及一些其他的优化。</p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%2024.png" alt="Untitled"></p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%2025.png" alt="Untitled"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>个人觉得是干货蛮蛮的一场分享，并且这个视频应该也是UOD今年播放量最多的一个视频。我看的时候有4.7w播放量。</p><p><img src="/2024/01/20/%E3%80%8A%E9%B8%A3%E6%BD%AE%E3%80%8B%E5%9F%BA%E4%BA%8E%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E4%E7%9A%84%E5%A4%9A%E5%B9%B3%E5%8F%B0%E6%95%88%E6%9E%9C%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/Untitled%2026.png" alt="Untitled"></p><p>下一期应该是写下字节S1工作室或者是实习老东家完美的诛仙2的分享（如果我没有🕊的话）</p>]]></content>
      
      
      <categories>
          
          <category> Game Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
            <tag> GameEngine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rendering God of War Ragnarok</title>
      <link href="/2023/09/21/Rendering-God-of-War-Ragnarok/"/>
      <url>/2023/09/21/Rendering-God-of-War-Ragnarok/</url>
      
        <content type="html"><![CDATA[<h1 id="Rendering-God-of-War-Ragnarok"><a href="#Rendering-God-of-War-Ragnarok" class="headerlink" title="Rendering God of War Ragnarok"></a>Rendering God of War Ragnarok</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>演讲的主持人是在2020年作为渲染的主程序加入Santa Monica的，在这之前是FarCry的项目组工作。刚来的时候渲染组里有6个人，之后随着项目的增长加到了10个人。</p><p>同时他也强调了自己其实是在开放世界项目的经验较为丰富，对这种线性叙事的游戏开发并不是很熟悉。</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled.png" alt="Untitled"></p><h2 id="Jira"><a href="#Jira" class="headerlink" title="Jira"></a>Jira</h2><p>首先上来讲了个项目管理工具，我表示直接跳过，对我这种大头兵暂时没有什么帮助。感兴趣的可以点下面的链接。</p><p><a href="https://www.atlassian.com/software/jira">Jira | Issue &amp; Project Tracking Software | Atlassian</a></p><h1 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h1><p>总的来看需要解决的问题分为4个部分</p><ul><li>Narrative Features</li><li>Visual Improvement and Art workflow</li><li>PlayStation 5 Enhancement</li><li>Helping Ourselves</li></ul><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%201.png" alt="Untitled"></p><h2 id="Narrative-Features-我该怎么翻译这个东西"><a href="#Narrative-Features-我该怎么翻译这个东西" class="headerlink" title="Narrative Features (我该怎么翻译这个东西)"></a>Narrative Features (我该怎么翻译这个东西)</h2><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%202.png" alt="Untitled"></p><ul><li><strong>Snow and Ice</strong></li></ul><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%203.png" alt="Untitled"></p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%204.png" alt="Untitled"></p><p>在前作里面虽然有雪，但是雪的深度并不够深，无法体现芬布尔之冬，不过他这里没有解释这套新的雪的系统的实现，因为他的同事已经做了该系统的分享（<a href="https://www.gdcvault.com/play/1028844/Advanced-Graphics-Summit-Reinventing-the">GDC Vault - Advanced Graphics Summit: Reinventing the Wheel for Snow Rendering</a>），故这里就不再赘述。</p><p>至于冰的实现的话说是会到Siggraph上进行分享，有知道的同学可以给个链接（懒狗没有找到）。</p><ul><li>Time of Day</li></ul><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%205.png" alt="Untitled"></p><p>没有给出什么有价值的信息，表示跳过</p><ul><li>Ragnarok</li></ul><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%206.png" alt="Untitled"></p><p>这里主要谈到的诸神黄昏这个场景的挑战是同屏的人数太多了，并且有大量的动画在播放，给CPU的压力有亿点大。所以根据距离做了个切分，远景部分用flip book animation，近景是正常动画，然后中距离用的是提前录制好的动画进行循环播放。</p><h2 id="Visual-Improvement-and-Art-workflow"><a href="#Visual-Improvement-and-Art-workflow" class="headerlink" title="Visual Improvement and Art workflow"></a>Visual Improvement and Art workflow</h2><p>强调改进工作流从而让艺术家们用更短的时间达到更高的质量。</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%207.png" alt="Untitled"></p><ul><li><strong>Lighting and GI Baking</strong></li></ul><p>首先说了下当前光照强度计算方式的问题。</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%208.png" alt="Untitled"></p><p>战神之前是用的相对光照强度，假设场景中有一个基本光源，然后其他所有的光源的Intensity都是相对于这个基本光源进行计算。</p><p>这套系统的优势有两点，在FP16的精度限制下没有太大问题，而且在解决场景之间的光照时会更少出现冲突。</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%209.png" alt="Untitled"></p><p>至于缺点则是这并非行业内的标准，导致新来的同事不能很好的快速上手这套光照系统。并且在游戏里其实并没有所谓的BaseLight给你当作参考，从而导致游戏的光照缺乏很好的一致性）。</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2010.png" alt="Untitled"></p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2011.png" alt="Untitled"></p><p>在Diss完光照之后，又说了下当前GI的Build太慢了，生产力及其低下。</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2012.png" alt="Untitled"></p><p>也就是说在Light这块的问题就是上面图片总结的4个老大难。</p><ul><li>设置个简单光照都这么多事，不想干了，开摆</li><li>所谓“正确”的设置也很难做到，不想干了，开摆</li><li>每次要手动构建GI而且还经常容易过时，动一动又要重新手动烘焙，不想干了，开摆</li><li>没人知道当前用的光照单位是啥，不想干了，开摆</li></ul><p>所以接下来就提出了对应的解决方案</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2013.png" alt="Untitled"></p><p>可以看到基本上是一一对应相关的痛点。</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2014.png" alt="Untitled"></p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2015.png" alt="Untitled"></p><p>在调整完之后可以看到整体的光照效果要好了一些（原来的那个太亮了）。</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2016.png" alt="Untitled"></p><p>之后就是开发一个自动Build GI的工具（工具管线是非常重要的！）。</p><ul><li><strong>Reflection and Refraction</strong></li></ul><p>在解决完光照问题之后，就开始着手反射和折射的相关优化。</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2017.png" alt="Untitled"></p><p>之前的做法是把参与反射和折射的几何渲染到两张RT里面，然后这些参与反射折射的几何体是艺术家手动指定。</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2018.png" alt="Untitled"></p><p>这么做的问题首先是不合常规的光照管线，不得不在额外在ForwardShading里面进行对应的处理，并且默认情况下毫无反射与折射，视觉效果难以让人满意。</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2019.png" alt="Untitled"></p><p>难以维护的结果自然就是工作效率的急剧下降（开摆！）</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2020.png" alt="Untitled"></p><p>然后结果就是更换到基于屏幕空间的做法了（正常来讲这个不应该才是正常解决方案么？为啥战神之前喜欢Geometry的做法？我不理解）。</p><h2 id="PlayStation-5-Enhancement"><a href="#PlayStation-5-Enhancement" class="headerlink" title="PlayStation 5 Enhancement"></a>PlayStation 5 Enhancement</h2><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2021.png" alt="Untitled"></p><p>首选谈了下PS5版本和PS4版本的参数以及目标性能。</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2022.png" alt="Untitled"></p><p>然后还说了下PS5版本独有的一些Feature</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2023.png" alt="Untitled"></p><p>然后老哥又讲了讲自家的RayTrace Cubemap是怎么做的（怎么又回到反射去了）。</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2024.png" alt="Untitled"></p><p>看起来是SSR和光追结合在一起做的GI效果。</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2025.png" alt="Untitled"></p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2026.png" alt="Untitled"></p><p>可以看到开了这套RayTrace CubeMap之后，反射的错位现象基本上消失了（仔细观察柱子的反射）。</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2027.png" alt="Untitled"></p><p>RayTracing的话不是对整个场景的复杂几何做，而是对ProxyMesh做，从而减少复杂度。</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2028.png" alt="Untitled"></p><p>在4k下的性能如上图所示，感觉还是可以接受的。</p><p>之后老哥又讲了讲ContactShadow是怎么处理的，这部分内容较多，所以建议大家去翻看原视频，大意其实也是基于光线追踪的做法。</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2029.png" alt="Untitled"></p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2030.png" alt="Untitled"></p><p>可以看到新做法的阴影要锐利很多（观察阿特柔斯的弓在身上的投影）。</p><p>基于Raytracing的做法其实主要是将光照计算的更加精确，从而减少一些传统光栅化管线里面的漏光问题。</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2031.png" alt="Untitled"></p><p>然后又谈了谈SSAO升级到SSDO很有帮助，然后又加了SSGI（怎么开始觉得有点像Lumen了）。</p><p>PlayStation 5 Enhancement这一段感觉其实主要还是讲的利用硬件光追做点图形Feautre，并没有太多实际上的平台优化出现。</p><h2 id="Helping-Ourselves"><a href="#Helping-Ourselves" class="headerlink" title="Helping Ourselves"></a>Helping Ourselves</h2><p>个人感觉无干货，叠甲过</p><h2 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h2><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2032.png" alt="Untitled"></p><p>要优化，首先就要有性能标准，不过这里强调了GPU这边要把异步计算关了进行Profile。</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2033.png" alt="Untitled"></p><p>嗯？这个ImGUI不会是我想的那个ImGUI吧，没想到已经打入到3A项目中，表示惊讶，我还以为大厂的引擎会有更加炫酷的Profile工具。</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2034.png" alt="Untitled"></p><p>强调开会前大家要定下自己要研究的领域，不然开会就会很尴尬，没人有所准备。</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2035.png" alt="Untitled"></p><p>在Shader上的问题则是LightingShader的复杂度过高，且VGPR的使用也过多。</p><p>(Tips : VGPR相关可以查看<a href="https://homes.cs.washington.edu/~wysem/publications/quals-gpgpu-vrf.pdf">quals-gpgpu-vrf.pdf (washington.edu)</a>)</p><p>所以为了解决这个问题，就写了一个VGPR的分析工具（工具很重要！），可以从Shader指令里面分析VGPR的使用。</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2036.png" alt="Untitled"></p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2037.png" alt="Untitled"></p><p>至于在阴影上的优化则是在静态物体和角色上也用ProxyMesh。并且之后讲了下高效的利用Htile（我猜是PS5上的专门硬件？）来进行ShadowMap的优化。</p><p><img src="/2023/09/21/Rendering-God-of-War-Ragnarok/Untitled%2038.png" alt="Untitled"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>成功离不开团队里的每一个人！</p><p>每次看到这些3A游戏，总是会感叹别人在项目管理以及工具流程上面的先进，希望有一天自己也能投身于这种项目，做做喜欢的东西吧。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rendering </tag>
            
            <tag> GDC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulkan MultiThread Tips</title>
      <link href="/2023/08/06/Vulkan-MultiTHead-Tips/"/>
      <url>/2023/08/06/Vulkan-MultiTHead-Tips/</url>
      
        <content type="html"><![CDATA[<h1 id="Vulkan-MultiThread-Tips"><a href="#Vulkan-MultiThread-Tips" class="headerlink" title="Vulkan MultiThread Tips"></a>Vulkan MultiThread Tips</h1><h2 id="Vulkan-RenderPass-整体的执行流程"><a href="#Vulkan-RenderPass-整体的执行流程" class="headerlink" title="Vulkan RenderPass 整体的执行流程"></a>Vulkan RenderPass 整体的执行流程</h2><p><img src="/2023/08/06/Vulkan-MultiTHead-Tips/Untitled.png" alt="Untitled"></p><h2 id="Vulkan多线程压力分析"><a href="#Vulkan多线程压力分析" class="headerlink" title="Vulkan多线程压力分析"></a>Vulkan多线程压力分析</h2><p>When one of the render passes in the application contains a lot of draw calls, such as the gbuffer pass, for CPU submission efficiency it’s important to split the draw calls into multiple groups and record them on multiple threads. There are two ways to do this:</p><ul><li>Record primary command buffers that render chunks of draw calls into the same framebuffer, using <code>vkCmdBeginRenderPass</code> and <code>vkCmdEndRenderPass</code>; execute the resulting command buffers using <code>vkQueueSubmit</code> (batching submits for efficiency)</li><li>Record secondary command buffers that render chunks of draw calls, passing the render pass to <code>vkBeginCommandBuffer</code> along with <code>VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</code>; use <code>vkCmdBeginRenderPass</code> with <code>VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS</code> in the primary command buffer, followed by <code>vkCmdExecuteCommands</code> to execute all recorded secondary command buffers</li></ul><p>While on immediate mode GPUs the first approach can be viable, and it can be a bit easier to manage wrt synchronization points on the CPU, it’s vital to use the second approach on GPUs that use tiled rendering instead. Using the first approach on tilers would require that the contents of the tiles is flushed to memory and loaded back from memory between each command buffer, which is catastrophic for performance.</p><p>上述分析主要讲述了一个RenderPass中DrawCall压力过高时，应该如何进行优化。在移动端上不利用多条Primary Command Buffer的原因是Primary Command Buffer的提交会把Tile中的数据写回到主存中，这肯定是dame的。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://zeux.io/2020/02/27/writing-an-efficient-vulkan-renderer/#:~:text=Writing%20an%20efficient%20Vulkan%20renderer%201%20Abstract%20Vulkan,on%20different%20hardware.%20...%203%20Descriptor%20sets%20">Writing an efficient Vulkan renderer</a></p>]]></content>
      
      
      <categories>
          
          <category> Vulkan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vulkan </tag>
            
            <tag> MultiThread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大世界渲染基础</title>
      <link href="/2023/07/25/%E5%A4%A7%E4%B8%96%E7%95%8C%E6%B8%B2%E6%9F%93%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/07/25/%E5%A4%A7%E4%B8%96%E7%95%8C%E6%B8%B2%E6%9F%93%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="地形，大气，以及云的渲染系统"><a href="#地形，大气，以及云的渲染系统" class="headerlink" title="地形，大气，以及云的渲染系统"></a>地形，大气，以及云的渲染系统</h1><h2 id="地形渲染方案"><a href="#地形渲染方案" class="headerlink" title="地形渲染方案"></a>地形渲染方案</h2><h3 id="地形管理"><a href="#地形管理" class="headerlink" title="地形管理"></a>地形管理</h3><p><img src="/2023/07/25/%E5%A4%A7%E4%B8%96%E7%95%8C%E6%B8%B2%E6%9F%93%E5%9F%BA%E7%A1%80/Untitled.png" alt="Untitled"></p><p>根据视距来进行地形的Tessellation，远处的三角形网格密度低而近处高。</p><p>而至于具体的Subdivision方法，可以分为如下</p><ul><li>Triangle Based Subdivision</li><li>QuadTree-Based Subdivision</li></ul><p>这里关键的一点是要明白T-Junction是什么，该怎么解决。</p><h3 id="材质采样"><a href="#材质采样" class="headerlink" title="材质采样"></a>材质采样</h3><p><img src="/2023/07/25/%E5%A4%A7%E4%B8%96%E7%95%8C%E6%B8%B2%E6%9F%93%E5%9F%BA%E7%A1%80/Untitled%202.png" alt="Untitled"></p><p>这里要注意TextureArray和3D Texture的区别，不过TextureArray的cache miss率较高，有点费。</p><h3 id="Virtual-Texture"><a href="#Virtual-Texture" class="headerlink" title="Virtual Texture"></a>Virtual Texture</h3><p><img src="/2023/07/25/%E5%A4%A7%E4%B8%96%E7%95%8C%E6%B8%B2%E6%9F%93%E5%9F%BA%E7%A1%80/Untitled%203.png" alt="Untitled"></p><p>当前一统天下的方案，大部分现代地形的管理都是通过Virtual Texture来进行。</p><h2 id="私货"><a href="#私货" class="headerlink" title="私货"></a>私货</h2><p><img src="/2023/07/25/%E5%A4%A7%E4%B8%96%E7%95%8C%E6%B8%B2%E6%9F%93%E5%9F%BA%E7%A1%80/Untitled%204.png" alt="Untitled"></p><h2 id="天空以及大气渲染"><a href="#天空以及大气渲染" class="headerlink" title="天空以及大气渲染"></a>天空以及大气渲染</h2><p>在做这方面的渲染时，一定要注意到<strong>天空</strong>和<strong>云</strong>要分开来考虑<strong>。</strong></p><ul><li>光与介质的交互方式</li></ul><p><img src="/2023/07/25/%E5%A4%A7%E4%B8%96%E7%95%8C%E6%B8%B2%E6%9F%93%E5%9F%BA%E7%A1%80/Untitled%205.png" alt="Untitled"></p><ul><li>Volume Rendering Equation</li></ul><p><img src="/2023/07/25/%E5%A4%A7%E4%B8%96%E7%95%8C%E6%B8%B2%E6%9F%93%E5%9F%BA%E7%A1%80/Untitled%206.png" alt="Untitled"></p><ul><li>Scattering Type</li></ul><p><strong>Rayleigh Scattering</strong> : 当参与散射的粒子直径远小于光的波长的时候，波长越短的光自然反射的越厉害，即反射的大部分是蓝光以及紫光。</p><p>$\lambda: 波长，h:海拔高度$</p><p>参数：</p><p><img src="/2023/07/25/%E5%A4%A7%E4%B8%96%E7%95%8C%E6%B8%B2%E6%9F%93%E5%9F%BA%E7%A1%80/Untitled%207.png" alt="Untitled"></p><p><strong>Mie Scattering : 参与散射的粒子直径大于或者接近于光的波长时候会发生的散射现象，这种散射发生时似乎是会对任意波长的光都产生同样的散射效果。</strong></p><p><img src="/2023/07/25/%E5%A4%A7%E4%B8%96%E7%95%8C%E6%B8%B2%E6%9F%93%E5%9F%BA%E7%A1%80/Untitled%208.png" alt="Untitled"></p><p><img src="/2023/07/25/%E5%A4%A7%E4%B8%96%E7%95%8C%E6%B8%B2%E6%9F%93%E5%9F%BA%E7%A1%80/Untitled%209.png" alt="Untitled"></p><h3 id="当前业界主流方法"><a href="#当前业界主流方法" class="headerlink" title="当前业界主流方法"></a>当前业界主流方法</h3><p><img src="/2023/07/25/%E5%A4%A7%E4%B8%96%E7%95%8C%E6%B8%B2%E6%9F%93%E5%9F%BA%E7%A1%80/Untitled%2010.png" alt="Untitled"></p><h2 id="云"><a href="#云" class="headerlink" title="云"></a>云</h2><p><img src="/2023/07/25/%E5%A4%A7%E4%B8%96%E7%95%8C%E6%B8%B2%E6%9F%93%E5%9F%BA%E7%A1%80/Untitled%2011.png" alt="Untitled"></p><p>除了这种基于物理的算法，往往还有基于2D面片的做法。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BigWorld Rendering </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后处理调研</title>
      <link href="/2023/06/30/%E5%90%8E%E5%A4%84%E7%90%86%E8%B0%83%E7%A0%94/"/>
      <url>/2023/06/30/%E5%90%8E%E5%A4%84%E7%90%86%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="后处理调研"><a href="#后处理调研" class="headerlink" title="后处理调研"></a>后处理调研</h1><h2 id="相关论文和博客"><a href="#相关论文和博客" class="headerlink" title="相关论文和博客"></a>相关论文和博客</h2><ul><li><strong>Post-processing Effects on Mobile: Optimization and Alternatives</strong></li></ul><p><a href="https://community.arm.com/arm-community-blogs/b/graphics-gaming-and-vr-blog/posts/post-processing-effects-on-mobile-optimization-and-alternatives">https://community.arm.com/arm-community-blogs/b/graphics-gaming-and-vr-blog/posts/post-processing-effects-on-mobile-optimization-and-alternatives</a></p><ul><li><strong>Bandwidth Efficient Rendering ARM — 这篇不错，讲述了移动端下的渲染优化应该怎么做</strong></li></ul><h2 id="HDR-管线研究"><a href="#HDR-管线研究" class="headerlink" title="HDR 管线研究"></a>HDR 管线研究</h2><h2 id="Volumetric-Fog-And-God-Ray"><a href="#Volumetric-Fog-And-God-Ray" class="headerlink" title="Volumetric Fog And God Ray"></a>Volumetric Fog And God Ray</h2><p><a href="https://zhuanlan.zhihu.com/p/258069994">UE4:三种圣光 God Rays 的做法</a></p><p><a href="https://www.bilibili.com/video/BV1sJ411B7oX/?from=seopage&amp;vd_source=ea6df38502a795b7533aa33b78bf1159">[技巧分享] 体积雾圣光 | God Rays Using Volumetric Fog(官方汉化)_哔哩哔哩_bilibili</a></p><p>(1) Geometry Material : 利用模型和材质在需要进行GodRay的地方进行放置，较为简单，但是看起来会比较廉价。</p><p>(2) LightShafts : 调整光源属性中LightShaft项，目前是只有方向光有这种功能。</p><p>LigthShaft中的实现其实很简单，即从整张画面中抽离出画面高亮的部分，对高亮部分做径向模糊(radial blur)，然后将模糊的高光图也原图进行混合。</p><p>(3) Volumetric Fog : 自带圣光，但是开销较大。</p><p><strong>科普 :</strong> GodRay是丁达尔效应的一种体现，在光的<a href="https://baike.baidu.com/item/%E4%BC%A0%E6%92%AD%E8%BF%87%E7%A8%8B/1195094?fromModule=lemma_inlink">传播过程</a>中，光线照射到粒子时，如果粒子大于<a href="https://baike.baidu.com/item/%E5%85%A5%E5%B0%84%E5%85%89/4923778?fromModule=lemma_inlink">入射光</a>波长很多倍，则发生<a href="https://baike.baidu.com/item/%E5%85%89%E7%9A%84%E5%8F%8D%E5%B0%84/905821?fromModule=lemma_inlink">光的反射</a>；如果粒子小于入射光波长，则发生光的<a href="https://baike.baidu.com/item/%E6%95%A3%E5%B0%84?fromModule=lemma_inlink">散射</a>，这时观察到的是光波环绕微粒而向其四周放射的光，称为<a href="https://baike.baidu.com/item/%E6%95%A3%E5%B0%84%E5%85%89/6028032?fromModule=lemma_inlink">散射光</a>或乳光。丁达尔效应就是光的<a href="https://baike.baidu.com/item/%E6%95%A3%E5%B0%84%E7%8E%B0%E8%B1%A1/3198326?fromModule=lemma_inlink">散射现象</a>或称乳光现象。由于真溶液粒子直径一般不超过1nm，胶体粒子介于溶液中溶质粒子和<a href="https://baike.baidu.com/item/%E6%B5%8A%E6%B6%B2/10712430?fromModule=lemma_inlink">浊液</a>粒子之间，其直径在1~100nm。小于<a href="https://baike.baidu.com/item/%E5%8F%AF%E8%A7%81%E5%85%89/1241853?fromModule=lemma_inlink">可见光</a>波长（400nm～700nm），因此，当可见光透过胶体时会产生明显的散射作用。而对于<a href="https://baike.baidu.com/item/%E7%9C%9F%E6%BA%B6%E6%B6%B2/6777874?fromModule=lemma_inlink">真溶液</a>，虽然分子或离子更小，但因散射光的强度随散射粒子体积的减小而明显减弱，因此，真溶液对<a href="https://baike.baidu.com/item/%E5%85%89%E7%9A%84%E6%95%A3%E5%B0%84/907259?fromModule=lemma_inlink">光的散射</a>作用很微弱。此外，散射光的强度还随<a href="https://baike.baidu.com/item/%E5%88%86%E6%95%A3%E4%BD%93%E7%B3%BB/1738034?fromModule=lemma_inlink">分散体系</a>中粒子浓度增大而增强。</p><p>所以说，胶体能有丁达尔现象，而溶液几乎没有，可以采用丁达尔现象来区分胶体和溶液，注意：当有光线通过<a href="https://baike.baidu.com/item/%E6%82%AC%E6%B5%8A%E6%B6%B2/9402945?fromModule=lemma_inlink">悬浊液</a>时有时也会出现光路，但是由于悬浊液中的颗粒对光线的阻碍过大，使得产生的光路很短。— 取自百度百科</p><h2 id="Bloom"><a href="#Bloom" class="headerlink" title="Bloom"></a>Bloom</h2><p>所有的Bloom大体都会分为3步</p><ul><li>Sperate : 分离出来超过亮度阈值的区域</li><li>Blur : 将亮部进行模糊 (通常是高斯模糊或者卷积)</li><li>Combine : 将模糊过的高光部分与原图像进行混合</li></ul><p>但是有不少人提到过Unreal的泛光效果偏白，并且亮度过于集中，虽然这的确Physical Based，但是从美观来说并不理想。</p><h3 id="带宽优化"><a href="#带宽优化" class="headerlink" title="带宽优化"></a>带宽优化</h3><p><img src="/2023/06/30/%E5%90%8E%E5%A4%84%E7%90%86%E8%B0%83%E7%A0%94/Untitled.png" alt="Untitled"></p><h2 id="Depth-of-Filed"><a href="#Depth-of-Filed" class="headerlink" title="Depth of Filed"></a>Depth of Filed</h2><p>官方文档在这方面做的不错  </p><p><a href="https://docs.unrealengine.com/5.2/zh-CN/cinematic-depth-of-field-in-unreal-engine/">过场动画景深</a></p><ul><li>要注意的一点是<strong>焦距(Focal Length)</strong> 和 <strong>对焦距离 (Focal Distance)</strong> 的区别，焦距指的是镜头中心到成像背板的距离，而<strong>对焦距离（Focus Distance）</strong> 是指从摄像机镜头中心到对焦的拍摄对象的距离。</li></ul><h2 id="ToneMapping"><a href="#ToneMapping" class="headerlink" title="ToneMapping"></a>ToneMapping</h2><p>当前ToneMapping的一些问题，对图像单独进行全局的ToneMap可能并不是可充分，会丢失掉HDR中的许多细节，所以需要再进行一次Local ToneMapping来进行处理。</p><p><a href="https://zhuanlan.zhihu.com/p/519457212">Tonemapping不够用了: Local Tonemapping方案总结</a></p><p><a href="https://bartwronski.com/2016/08/29/localized-tonemapping/">Localized tonemapping – is global exposure and global tonemapping operator enough for video games?</a></p><ul><li>色调映射（Tone mapping）是解决这个问题的良药。Tone mapping 有两种，一种是对屏幕上所有的像素用同一个函数调整亮度，即 Global tone mapping；另一种则会根据每个像素周围的像素智能地根据上下文 (context) 进行调整亮度，即 Local tone mapping，后者往往更为有效，并且逐渐</li></ul><p>不过UE5已经推出了Local Exposure，所用的方法就是上文中利用Bialter Grid的方案 (Unreal 这图形Feature的更新速度也太快了，基本上啥都有)。</p><h2 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h2><p>当前感兴趣的方法 ： <strong>Stochastic Screen Space Reflections</strong></p><p>传统方法的实现一言以蔽之就是在屏幕空间内做RayMarching，判断相交的像素，看起来如何加速RayMarching的效率是重中之重。</p><h2 id="AO"><a href="#AO" class="headerlink" title="AO"></a>AO</h2><ul><li>HBAO - <strong><strong>Image-Space Horizon-Based Ambient Occlusion</strong></strong></li></ul><p><img src="/2023/06/30/%E5%90%8E%E5%A4%84%E7%90%86%E8%B0%83%E7%A0%94/Untitled 1.png" alt="Untitled"></p><p>其中的一个关键是如何通过深度来还原场景信息</p><p><a href="https://zhuanlan.zhihu.com/p/367257314">【知识补充】深度信息还原位置和法线</a></p><ul><li>HBAO+</li></ul><p><a href="https://developer.nvidia.com/rendering-technologies/horizon-based-ambient-occlusion-plus">NVIDIA Horizon-Based Ambient Occlusion Plus (HBAO+)</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostProcessing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Memory consistent and coherent</title>
      <link href="/2023/05/27/Memory-consistent-and-coherent/"/>
      <url>/2023/05/27/Memory-consistent-and-coherent/</url>
      
        <content type="html"><![CDATA[<h2 id="缓存的写回策略"><a href="#缓存的写回策略" class="headerlink" title="缓存的写回策略"></a>缓存的写回策略</h2><p>高速缓存（<strong>Cache</strong>）是一种将数据副本临时存储在可快速访问的存储内存中的技术。缓存将最近使用的数据存储在小内存中，以提高访问数据的速度。它充当 <strong>RAM</strong> 和 <strong>CPU</strong> 之间的缓冲区，从而提高处理器可用数据的速度。</p><p>每当处理器想要写入一个字时，它都会检查它想要写入数据的地址是否存在于缓存中。如果地址存在于缓存中，即写入命中（<strong>Write Hit</strong>）。</p><p>我们可以更新缓存中的值并避免昂贵的主内存访问。但这会导致数据不一致（<strong>Inconsistent Data</strong>）问题。由于高速缓存和主存都有不同的数据，如在多处理器系统中，这将导致两个或多个共享主存的设备出现问题。</p><p>而写回策略一般来讲分为两种</p><ol><li><p><strong>写回(Write Back)</strong> : 当CPU对cache写命中时，只修改cache的内容不立即写入主存，只当此行被换出时才写回主存。这种策略使cache在CPU－主存之间，不仅在读方向而且在写方向上都起到高速缓存作用。对一cache行的多次写命中都在cache中快速完成修改， 只是需被替换时才写回速度较慢的主存，减少了访问主存的次数从而提高了效率。为支持这种策略，每个cache行必须配置一个修改位，以反映此行是否被CPU修改过。当某行被换出时，根据此行修改位为1还是为0，决定是将该行内容写回主存还是简单地弃之 而不顾。<br>　　对于cache写未命中，写回法的处理是为包含欲写字的主存块在cache分配一行，将此块整个拷贝到Cache后对其进行修改， 因为尔后对此块的多次读/写访问的可能性很大。拷贝主存块时虽已读访问到主存，但此时并不对主存块修改。因为换出的cache很可能此期间要写回主存，为避免此过程耗时太长，写未命中对将新块读入后，只在cache中进行写修改。统一地将主存写修改操作留待换出时进行。</p><p><strong>PS</strong> : 这种做法会带来严重的<strong>Memory Coherent</strong>问题，需要后续同步协议进行支持(<em>MESI</em>)。</p></li><li><p><strong>写通(Write Through)</strong> : 又称全写法，写透。是当cache写命中时，cache与主存同时发生写修改。这种策略 显然较好地维护了cache与主存的内容一致性，但这并不等于说全部解决了一致性问题。例如在多处理器系统中各CPU都有自己的cache，一个主存块若在多个cache中都有一份拷贝的话，某个CPU以写直达法来修改它的cache和主存时，其它cache中的原拷贝就过时了。即使在单处理器系统中，也有I／O设备不经过cache向主存写入的情况。总之，仍要关注一致性问题。 当cache写未命中时，只有直接向主存写入了，但此时是否将修改过的主存块取到cache，写直达法却有两种选择。一种是取来并且为它分配一个行位置，称为WTWA法（Write—Through—with—Write—Allocate）。另一种是不取称为WTNWA法（WriteThrough—With—NO—Write—Allocate）。前一种方法保持了cache / 主存的一致性，但操作复杂，而后一种方法操作简化，但命中率降低，内存的修改块只有在读未命中对cache 进行替换时，才有可能映射到cache 。 写直达法是写cache与写主存同步进行，其优点是cache每行无需设置一个修改位以及相应的判测逻辑。写直达法的缺点是，cache对CPU向主存的写操作无高速缓冲功能，降低了cache的功效。 </p></li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/571429282">透写和回写缓存（Write Through and Write Back in Cache</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Memory Model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译Unreal时遇到的一个小问题记录</title>
      <link href="/2023/04/10/%E7%BC%96%E8%AF%91Unreal%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/04/10/%E7%BC%96%E8%AF%91Unreal%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Toolchain-Error-Generating-Project-Files-for-VS-2022"><a href="#Toolchain-Error-Generating-Project-Files-for-VS-2022" class="headerlink" title="Toolchain Error Generating Project Files for VS 2022"></a>Toolchain Error Generating Project Files for VS 2022</h2><p>Unreal的构建系统是由C#来进行支持的，当我们拉取完Unreal的源码后，我们只要按照官方的指示走，在99%的情况下都不会出大问题。不过这次我却稍微碰到了一个从来没有看过的情况。</p><blockquote><p>Unable to find valid latest C++ toolchain for VisualStudio2022 x64</p></blockquote><p>报错提示为无法找到Visual Studio的C++工具链，当然实际上我清楚我的工具链是没有问题的，因为我已经用这套工具链用了很长时间，从来没有出现过类似的问题，故问题一定是在Unreal的build tool上，在互联网冲浪了一番后，我在官方论坛里面找到了答案。</p><p><a href="https://forums.unrealengine.com/t/toolchain-error-generating-project-files-for-vs-2022-ue-5-1/750069">https://forums.unrealengine.com/t/toolchain-error-generating-project-files-for-vs-2022-ue-5-1/750069</a></p><p>简单来说，当Unreal进行工具链检索时，它默认只会搜索<strong>Latest</strong>版本的工具链来进行构建，如果你的Visual Studio是Preview版的话，就会报我上面的那个错误。</p><p>具体解决方式就是把<code>Engine\Platforms\Hololens\Source\Programs\UnrealBuildTool\HoloLensProjectGenerator.cs</code>中第87行的代码修改为以下格式。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DirectoryReference? PlatformWinMDLocation = HoloLensPlatform.GetCppCXMetadataLocation(Compiler, <span class="string">&quot;Preview&quot;</span>, WindowsArchitecture.x64, Logger); <span class="comment">// 原先指定的是Latest</span></span><br></pre></td></tr></table></figure><p>修改完毕后就没什么问题，换上好点的固态硬盘和CPU，直接开编Unreal即可。</p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次奇妙的Vulkan Debug经历</title>
      <link href="/2023/04/09/%E4%B8%80%E6%AC%A1%E5%A5%87%E5%A6%99%E7%9A%84Vulkan-Debug%E7%BB%8F%E5%8E%86/"/>
      <url>/2023/04/09/%E4%B8%80%E6%AC%A1%E5%A5%87%E5%A6%99%E7%9A%84Vulkan-Debug%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="畏惧Vulkan吧"><a href="#畏惧Vulkan吧" class="headerlink" title="畏惧Vulkan吧"></a>畏惧Vulkan吧</h2><p>最近在跟着官方的Tutorial学Vulkan，不得不说深感其琐碎与复杂，画一个完整设置的三角形就需要大概1000行代码，这在传统的图形API上是难以想象的。但另一方面在画完三角形后，我又感觉自己打通了任督二脉，觉得自己好像抓住了这套渲染流程的精髓。于是在我加入Depth Buffer进入到3D世界时，就发现了一个奇妙的问题。</p><div align="center">    <img src="https://s2.loli.net/2023/04/09/racmxFtkdQM6Kel.png" width="50%" height="50%"></div><p>你可能会问，你这是传了个什么图上来，怎么是全黑的。是的，我也想问，为什么是全黑的，为什么我加了个深度测试后就变成全黑了，起初我是以为我的<code>pipeline</code>的配置写的有问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vk::PipelineDepthStencilStateCreateInfo depthStencilStateCreateInfo;</span><br><span class="line">depthStencilStateCreateInfo.<span class="built_in">setDepthTestEnable</span>(<span class="literal">true</span>)</span><br><span class="line">                           .<span class="built_in">setDepthWriteEnable</span>(<span class="literal">true</span>)</span><br><span class="line">                           .<span class="built_in">setDepthBoundsTestEnable</span>(<span class="literal">false</span>)</span><br><span class="line">                           .<span class="built_in">setStencilTestEnable</span>(<span class="literal">false</span>)</span><br><span class="line">                           .<span class="built_in">setMinDepthBounds</span>(<span class="number">0.0f</span>)</span><br><span class="line">                           .<span class="built_in">setMaxDepthBounds</span>(<span class="number">1.0f</span>)</span><br><span class="line">                           .<span class="built_in">setDepthCompareOp</span>(vk::CompareOp::eLess);</span><br><span class="line"></span><br><span class="line">pipelineCreateInfo.<span class="built_in">setPDepthStencilState</span>(&amp;depthStencilStateCreateInfo);</span><br></pre></td></tr></table></figure><p>但我仔细一看，我寻思这也没问题啊。故我又去打开RenderDoc看了看我的每个pass的输出。</p><div align="center">    <img src="https://s2.loli.net/2023/04/09/8XFWvHTN1pAbd7w.png"></div><p>？？？这是什么，为什么这么糊并且没有显示到的我的屏幕上。</p><p>然后当我放大了来看之后，我发现上面满满的都是<code>LOAD DONTCARE</code>，于是我立马就意识到发生了什么, 是我在<code>RenderPass</code>建立<code>depthAttachment</code>出了问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vk::AttachmentDescription depthAttachment;</span><br><span class="line">depthAttachment.<span class="built_in">setFormat</span>(vk::Format::eD32Sfloat)</span><br><span class="line">                .<span class="built_in">setInitialLayout</span>(vk::ImageLayout::eUndefined)</span><br><span class="line">                .<span class="built_in">setFinalLayout</span>(vk::ImageLayout::eDepthStencilAttachmentOptimal)</span><br><span class="line">                .<span class="built_in">setSamples</span>(vk::SampleCountFlagBits::e1)</span><br><span class="line">                .<span class="built_in">setStencilLoadOp</span>(vk::AttachmentLoadOp::eDontCare)</span><br><span class="line">                .<span class="built_in">setStencilStoreOp</span>(vk::AttachmentStoreOp::eDontCare)</span><br><span class="line">                .<span class="built_in">setLoadOp</span>(vk::AttachmentLoadOp::eClear) <span class="comment">// 万恶之首，应该写成eClear，并在后面的渲染流程中传入ClearValue</span></span><br><span class="line">                .<span class="built_in">setStoreOp</span>(vk::AttachmentStoreOp::eDontCare);</span><br></pre></td></tr></table></figure><p>在改为<code>eClear</code>并设置完clearValue之后，我们就可以重新看到图像了。</p><p><img src="https://s2.loli.net/2023/04/09/S4GFBQY1ZuP7t6k.png" alt="image.png"></p><p>真不错，鼓掌鼓掌，但是另一方面更让我体会到Vulkan里面稍微写错一点，就能让自己排查半天，而且很明显这种错误是完全不可能被验证层找到，只能通过外部工具来Debug，唉，还是得畏惧Vulkan啊，更别说这里还没涉及到什么内存管理和同步之类的复杂话题。感觉好日子还在后头了。</p>]]></content>
      
      
      <categories>
          
          <category> GPU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vulkan </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CP中的一些小技巧</title>
      <link href="/2023/04/07/CP%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2023/04/07/CP%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="从Codeforces里面学到的一些小Trick"><a href="#从Codeforces里面学到的一些小Trick" class="headerlink" title="从Codeforces里面学到的一些小Trick"></a>从Codeforces里面学到的一些小Trick</h2><p>本文主要是来自Codeforeces里面的一篇博客。</p><p><a href="https://codeforces.com/blog/entry/107717">PSA: don’t use these functions unless you really, really need to</a></p><ul><li>计算$\frac{a}{b}$向上取整, 直接用 <code>(a + b - 1) / b</code>, 不要用<code>ceil((double) a / (double) b)</code></li><li>计算正整数根号，不要直接使用<code>sqrt</code>,转而使用二分(其实这条我并不是很理解，按理说现代的sqrt的性能是没问题的，会直接翻译到硬件指令)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// works for at least up to (2**31 &amp;mdash; 1)**2</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">int_sqrt</span> <span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (ll k = <span class="number">1LL</span> &lt;&lt; <span class="number">30</span>; k != <span class="number">0</span>; k /= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((ans + k) * (ans + k) &lt;= x) &#123;</span><br><span class="line">      ans += k;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>算$a^b$的时候不要用<code>pow(a, b)</code>，而是手动循环进行计算。</li><li>计算正整数的$log_2(a)$时，不要直接使用<code>log2(a)</code>，而是使用基于<code>__builtin_clz</code>或者<code>__builtin_clzll</code>的方法，如果有C++20的话，也可以用<code>bit_width</code>的库函数。其实也就是奉劝我们从二进制表示来进行计算，而不是直接根据10进制的数学方法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Simple Trick </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tangent Space Normal Mapping</title>
      <link href="/2023/04/04/Tangent-Space-Normal-Mapping/"/>
      <url>/2023/04/04/Tangent-Space-Normal-Mapping/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要法线贴图"><a href="#为什么要法线贴图" class="headerlink" title="为什么要法线贴图"></a>为什么要法线贴图</h2><p><strong>法线贴图(Normal Map)</strong>正如其名所述，是一张包含了法线相关信息的贴图(<del>我在说什么废话</del>)。要介绍为什么使用法线贴图的话，我们首先得了解这样一个事实，在光照和着色算法不变的情况下，我们的图形质量高低基本上取决于我们模型的信息密度，更进一步说的话就是模型的三角形数量。</p><div>    <img src="https://s2.loli.net/2023/04/04/8adrDLUFEfyqMlK.png"></div><p>而这一概念也被应用到一种叫做<strong>LOD(level of detail)</strong>的技术之中，可以看到最右面的模型只有750个三角形，导致它头部的光圈基本上坍缩成了一个矩形，渲染质量显然没有最左面的好。</p><p>在有了上面的认知之后，大概率我们会有一个错误的认知，好，无脑堆素材质量就行了，看我一个模型整他个上亿个三角形，就不信出不了好画面。这种力大砖飞的情况虽然确实能显著提高渲染质量，但是游戏的包体大小也会成倍增加，并且这么高模的模型导入游戏，游戏渲染的压力会急速上升，如果没有UE5的Nanite这种技术来做简化，我们基本上没有希望达到实时渲染的速度要求。</p><p>不过聪明的人们想到了一种办法来进行近似，其原理大概是这样，虽然我们无法直接导入高模的模型，但是要是我们利用其表面的法线信息以及一个相对低模的模型，也能达到一个相对较好的渲染质量，同时也有一个不错的性能保证。</p><p>而这也就是所谓的法线贴图灵感的一个重要来源，高模模型烘焙出一张法线贴图配合上简化模型进行渲染，这是实时渲染中的一个常用trick。</p><div align="center">    <img src="https://s2.loli.net/2023/04/04/P9I4pqtzmTfVOok.png" width="50%" height="50%"></div><p>上面这张看起来有点阴间的图便是一张常见的法线贴图示例。但是很快你就会发现问题，等下，为什么整张图都是蓝色的，法线如果转换为颜色向量的话，不应该是什么颜色都有的么？</p><p>是的我的朋友，你发现了一个盲点，我们只说了我们会利用法线贴图存储法线相关信息，但是我们并没有说明在什么坐标系下进行存储，也没有说明具体存的是什么东西，而这也就引出了我们下一个话题，也就是本文的标题<strong>切线空间法线贴图(Tangent Space Normal Mapping)</strong>。</p><h2 id="切线空间法线贴图"><a href="#切线空间法线贴图" class="headerlink" title="切线空间法线贴图"></a>切线空间法线贴图</h2><p>其实法线贴图确实有你想的那种彩色形式，如果我们把法线信息定义在世界空间(world space)下的话。</p><div>    <img src="https://s2.loli.net/2023/04/04/GUjzpTrWL4RHt8Q.png"></div><p>上述左边便是直接存储在世界空间中的结果，可以看到基本上是什么颜色都有，比较符合一开始的假设。所以问题就是，为什么我们看到的大部分法线贴图是右边这种蓝色为主的情况呢？</p><p>首先考虑下如果将法线存储在世界坐标系下的话会有什么问题，如果我们有一个帧动画的话，模型每时每刻都会发生形变，那么自然而然其每帧的法线贴图也要变化，这就很恐怖了，每帧一个法线贴图，什么家庭敢这么做。所以我们自然是无法将其定义在世界坐标系下，而是转而进入到<strong>切线空间(Tangent Space)</strong>之中进行定义。</p><div align="center">    <img src="https://s2.loli.net/2023/04/04/OxSuhcUfDikrZ86.png"></div><p>上图便是切线空间，在这个空间内，通过uv坐标我们便可以采样出一个Texel，这个Texel会是一个rgb的向量，记录的是在切线空间的法线向量，这里也就可以明白为什么这图是蓝色的，因为模型上大部分的点都不会在x，y轴上(对应r分量和g分量)偏移法线太多，基本上只有在z轴上稍微做个改动。</p><p>在得到了切线空间坐标系下的法线方向，之后我们通过构造一个TBN矩阵，即将TBN这三个向量作为基向量的矩阵，我们就可以将切线空间下的法线变换到相应坐标系中，最后再计算光照即可。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">   [...]</span><br><span class="line">   <span class="type">vec3</span> T = <span class="built_in">normalize</span>(<span class="type">vec3</span>(model * <span class="type">vec4</span>(aTangent,   <span class="number">0.0</span>))); <span class="comment">// 通常来讲模型自带</span></span><br><span class="line">   <span class="type">vec3</span> B = <span class="built_in">normalize</span>(<span class="type">vec3</span>(model * <span class="type">vec4</span>(aBitangent, <span class="number">0.0</span>))); <span class="comment">// aBitangent = cross(aNormal, aTangent)</span></span><br><span class="line">   <span class="type">vec3</span> N = <span class="built_in">normalize</span>(<span class="type">vec3</span>(model * <span class="type">vec4</span>(aNormal,    <span class="number">0.0</span>))); <span class="comment">// 模型自带</span></span><br><span class="line">   <span class="type">mat3</span> TBN = <span class="type">mat3</span>(T, B, N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过值得一提的是如果模型没给切线向量的话，我们自己就需要手算了。LearnOpenGL中有进行详细的解释，要是感兴趣的话可以看一看。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><p><a href="https://learnopengl.com/Advanced-Lighting/Normal-Mapping">https://learnopengl.com/Advanced-Lighting/Normal-Mapping</a></p></li><li><p><a href="https://github.com/ssloy/tinyrenderer/wiki/Lesson-6bis:-tangent-space-normal-mapping">Lesson 6bis: tangent space normal mapping · ssloy/tinyrenderer Wiki (github.com)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Normal Mapping </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬盘的基础知识总结</title>
      <link href="/2023/03/17/%E7%A1%AC%E7%9B%98%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/2023/03/17/%E7%A1%AC%E7%9B%98%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="总线，协议，接口"><a href="#总线，协议，接口" class="headerlink" title="总线，协议，接口"></a>总线，协议，接口</h2><p>最近发现自己退化的厉害，故为了防止病情的进一步恶化，我尝试简单的总结一下我最近学的相关知识，主要是与硬盘相关，毕竟这东西经常买，多知道一点还是有不少的好处的。</p><p>而在这篇文章中，我们不讨论机械硬盘或者固态硬盘中硬件原理，而是专门的总结一下与其相关的<strong>总线</strong>，<strong>接口</strong>，以及<strong>协议</strong>的相关知识。</p><ul><li><strong>总线</strong>：总线的任务主要是进行数据的传输，总线的性能主要是用<strong>带宽(bandwidth)</strong>来进行描述，其定义为总线在单位时间内所能传输的数据量，现在常见的总线有<strong>SATA</strong>, <strong>PCIE</strong>, <strong>SAS</strong>。</li><li><strong>接口</strong>: 硬盘中用来和主板接入的实际接触部分，没有这个东西你就没法把硬盘塞到主板上。</li><li><strong>协议</strong>: 用来定义和实现通信的一组规则，简而言之的话，就是硬件之间<strong>沟通</strong>的具体方法，现在常用的协议有<strong>ACHI</strong>，<strong>NVME</strong>，<strong>SCSI</strong>。</li></ul><p>通常来讲这三者要互相匹配，并且整体的速度上限往往是由总线来决定的，这里借用一张<a href="https://www.bilibili.com/video/BV1Qv411t7ZL/?spm_id_from=333.999.0.0&amp;vd_source=ea6df38502a795b7533aa33b78bf1159">硬件茶谈</a>中的图来进行描述。</p><div align="center">    <img src="https://s2.loli.net/2023/03/17/Jo8a3LTvq97SFj2.png"></div><p>如果以我们常买的固态硬盘为例的话，一般会为M.2接口，PCIe总线，NVMe协议这个组合。</p><p>这里顺便记录下常见的总线带宽上限，让自己稍微有个速度上定量的概念。</p><ul><li>SATA3.0 </li></ul><div class="table-container"><table><thead><tr><th>理论带宽</th><th>编码</th><th>换算为windows内显示传输速度</th></tr></thead><tbody><tr><td>6Gbps</td><td>8:10</td><td>600MB/S</td></tr></tbody></table></div><ul><li>PCIE</li></ul><div class="table-container"><table><thead><tr><th>PCIE版本</th><th>编码</th><th>x1</th><th>x4</th><th>x8</th><th>x16</th></tr></thead><tbody><tr><td>3.0</td><td>128b/130b/b</td><td>984.6MB/S</td><td>3.938GB/S</td><td>7.877GB/S</td><td>15.754GB/S</td></tr><tr><td>4.0</td><td>128b/130b/b</td><td>1.969GB/S</td><td>7.877GB/S</td><td>15.754GB/S</td><td>31.505GB/S</td></tr></tbody></table></div><ul><li>SAS 3.0</li></ul><div class="table-container"><table><thead><tr><th>理论带宽</th><th>编码</th><th>换算为windows内显示传输速度</th></tr></thead><tbody><tr><td>12Gbps</td><td>8:10</td><td>1.2GB/S</td></tr></tbody></table></div><p>这里PCIE的速率会随着你所使用的总线通道而上升，故给出多组数据。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1Qv411t7ZL/?spm_id_from=333.999.0.0&amp;vd_source=ea6df38502a795b7533aa33b78bf1159">【硬件科普】硬盘的SATA M.2 NGFF NVME是什么意思，详解硬盘的总线协议与接口</a></p><h5 id><a href="#" class="headerlink" title=" "></a> </h5>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulkan的各种presentation mode</title>
      <link href="/2023/03/03/vulkan%E7%9A%84%E5%90%84%E7%A7%8Dpresentation-mode/"/>
      <url>/2023/03/03/vulkan%E7%9A%84%E5%90%84%E7%A7%8Dpresentation-mode/</url>
      
        <content type="html"><![CDATA[<h2 id="Presentation-mode是什么"><a href="#Presentation-mode是什么" class="headerlink" title="Presentation mode是什么"></a>Presentation mode是什么</h2><p>在创建vulkan的swap chain的时候，我们有一项必须要指定的便是<code>VkPresentModeKHR</code>，这个是用来控制swap chain中的对象是如何显示到我们的屏幕之上。总的来看，vulkan支持以下4种方案：</p><ul><li><code>VK_PRESENT_MODE_IMMEDIATE_KHR</code></li><li><code>VK_PRESENT_MODE_FIFO_KHR</code></li><li><code>VK_PRESENT_MODE_FIFO_RELAXED_KHR</code></li><li><code>VK_PRESENT_MODE_MAILBOX_KHR</code></li></ul><p>并且在这4种方案中，只有<code>VK_PRESENT_MODE_FIFO_KHR</code>是vulkan规定必须要支持的显示模式，其他的不做要求。</p><h3 id="VK-PRESENT-MODE-IMMEDIATE-KHR"><a href="#VK-PRESENT-MODE-IMMEDIATE-KHR" class="headerlink" title="VK_PRESENT_MODE_IMMEDIATE_KHR"></a>VK_PRESENT_MODE_IMMEDIATE_KHR</h3><p>这个模式是最简单的一种情况，你渲染出来的图片直接就会被扔到显示器上进行显示，不会做任何同步。这种模式一般情况下是用来最大化你的fps的，通常强调输入延迟的fps游戏会搞这种显示模式。</p><h3 id="VK-PRESENT-MODE-FIFO-KHR-amp-VK-PRESENT-MODE-MAILBOX-KHR"><a href="#VK-PRESENT-MODE-FIFO-KHR-amp-VK-PRESENT-MODE-MAILBOX-KHR" class="headerlink" title="VK_PRESENT_MODE_FIFO_KHR &amp; VK_PRESENT_MODE_MAILBOX_KHR"></a>VK_PRESENT_MODE_FIFO_KHR &amp; VK_PRESENT_MODE_MAILBOX_KHR</h3><p>这两个可以放在一起说，基本上<code>FIFO</code>就是在一个固定的同步周期(即Vertical sync)里面，我们每次同步，都把当前渲染队列的第一张图拿出来给显示器来进行使用，这也是为什么这个模式会叫作<code>FIFO</code>，也就是先进先出模式。</p><div>    <img src="https://s2.loli.net/2023/03/03/D6dgoaqRezwjby8.png"></div><p><code>MAILBOX</code>总的来看的话就是<code>FIFO</code>的一个变种，但是不同的是，在<code>FIFO</code>中，每个framebuffer在被显示到屏幕之前，是不会重新绘制的，它会一直等到被显示到屏幕上。这也是问什么我们我会在图中看到<code>FIFO</code>模式下的绘制和呈现可能会有一个非常长的间隔，这无疑会增加玩家所感受到的输入延迟。<code>MAILBOX</code>的则改进了这个问题，这种模式下的GPU永不停歇，只要能画它就会去画，完全不考虑该framebuffer中图像是否已经被显示过。但是当然会带来一个问题就是很多的图像虽然被渲染了，但是并没有呈现到屏幕上，造成了很多资源浪费，而且GPU一直满载跑也很耗电，<strong>对移动端不是非常友好</strong>。</p><h3 id="VK-PRESENT-MODE-FIFO-RELAXED-KHR"><a href="#VK-PRESENT-MODE-FIFO-RELAXED-KHR" class="headerlink" title="VK_PRESENT_MODE_FIFO_RELAXED_KHR"></a>VK_PRESENT_MODE_FIFO_RELAXED_KHR</h3><p>这个模式就有点像<code>FIFO</code>和<code>IMMEDIATE</code>的混合体，<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPresentModeKHR.html">Vulkan Specs</a>将其描述为下</p><blockquote><p><code>VK_PRESENT_MODE_FIFO_RELAXED_KHR</code> specifies that the presentation engine generally waits for the next vertical blanking period to update the current image. If a vertical blanking period has already passed since the last update of the current image then the presentation engine does not wait for another vertical blanking period for the update, meaning this mode <strong>may</strong> result in visible tearing in this case. </p></blockquote><p>大意就是如果应用程序延迟，导致交换链的队列在上一次同步时为空，那么，如果应用程序在下一次同步前提交图像，图像会立即被显示，这一模式可能会导致画面撕裂现象。</p>]]></content>
      
      
      <categories>
          
          <category> GPU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vulkan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的类型推导</title>
      <link href="/2023/02/28/C-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/"/>
      <url>/2023/02/28/C-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="类型推导—Effective-modern-C-学习笔记"><a href="#类型推导—Effective-modern-C-学习笔记" class="headerlink" title="类型推导—Effective modern C++ 学习笔记"></a>类型推导—Effective modern C++ 学习笔记</h2><p>auto和template虽然用起来很爽，但是作为程序员我们应该了解C++编译器做了哪些事情，从而确实的保证整套机制能够顺利的运作。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板声明部分</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"><span class="comment">//调用部分</span></span><br><span class="line"><span class="built_in">f</span>(expr)</span><br></pre></td></tr></table></figure><br>模板类型推导就是关于如何根据expr的类型来推断出T的类型以及ParamType的类型。通常来讲，T和ParamType不会一样，因为ParamType往往会给T加上const或者引用之类的修饰。比如T可能是String类型，但ParamType是const String&amp;类型，这在平常的函数模板使用中是非常常见的一种情况。</p><p>但是即便刨除T和ParamType之间的类型不同，我们也需要知道这样一个事情，虽然T的类型推导应该完全依赖于expr的类型，但是实际上并非如此。T的类型推导不仅仅依赖于expr的类型，也取决于ParamType的类型。</p><p>具体来看的话，ParamType造成的影响可以分为三类来进行讨论。</p><h3 id="当ParamType是一个指针或引用，但不是通用引用"><a href="#当ParamType是一个指针或引用，但不是通用引用" class="headerlink" title="当ParamType是一个指针或引用，但不是通用引用"></a>当ParamType是一个指针或引用，但不是通用引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板声明部分</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"><span class="comment">//变量声明</span></span><br><span class="line"><span class="type">int</span> x=<span class="number">27</span>;                       <span class="comment">//x是int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx=x;                 <span class="comment">//cx是const int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx=x;                <span class="comment">//rx是指向作为const int的x的引用</span></span><br><span class="line"><span class="comment">//调用部分</span></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//T是int，param的类型是int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//T是const int，param的类型是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//T是const int，param的类型是const int&amp;</span></span><br></pre></td></tr></table></figure><p>这里面注意观察的其实就是f(cx)和f(rx)，即便传入参数类型是一个引用，T也并不会被推导为引用类型，这是因为在类型推导中，对象的引用性(reference-ness)会被忽略。不过从另一方面我们也可以看到常量性(constness)是没有被忽略的，传入一个const型的对象，T也会带有const。</p><p>同时如果更改一下这个ParamType的类型声明，我们可以看到一些不同的结果。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板声明部分</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; param)</span></span>;</span><br><span class="line"><span class="comment">//变量声明</span></span><br><span class="line"><span class="type">int</span> x=<span class="number">27</span>;                       <span class="comment">//x是int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx=x;                 <span class="comment">//cx是const int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx=x;                <span class="comment">//rx是指向作为const int的x的引用</span></span><br><span class="line"><span class="comment">//调用部分</span></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//T是int，param的类型是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//T是int，param的类型是const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//T是int，param的类型是const int&amp;</span></span><br></pre></td></tr></table></figure><br>如果我们将const属性声明在了函数参数的形参中，那么T将不会保留常量性。</p><h3 id="当ParamType是一个通用引用"><a href="#当ParamType是一个通用引用" class="headerlink" title="当ParamType是一个通用引用"></a>当ParamType是一个通用引用</h3><p>首先对于那些不太了解通用引用的人(Universal Reference)，我推荐Scott Meyers也就是本书作者在isocpp.org上的一篇<a href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">博客</a>，这里面详细讨论了什么是通用引用或者说万能引用。同时通用引用的符号容易让你以为这里的声明是右值引用，但其实两者完全不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板声明部分</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;              <span class="comment">//param现在是一个通用引用类型</span></span><br><span class="line"><span class="comment">//变量声明</span></span><br><span class="line"><span class="type">int</span> x=<span class="number">27</span>;                       <span class="comment">//x是int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx=x;                 <span class="comment">//cx是const int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx=x;                <span class="comment">//rx是指向作为const int的x的引用</span></span><br><span class="line"><span class="comment">//调用部分</span></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//x是左值，所以T是int&amp;，</span></span><br><span class="line">                                <span class="comment">//param类型也是int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//cx是左值，所以T是const int&amp;，</span></span><br><span class="line">                                <span class="comment">//param类型也是const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//rx是左值，所以T是const int&amp;，</span></span><br><span class="line">                                <span class="comment">//param类型也是const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>);                          <span class="comment">//27是右值，所以T是int，</span></span><br><span class="line">                                <span class="comment">//param类型就是int&amp;&amp;</span></span><br></pre></td></tr></table></figure><p>这里可以看到对于通用引用的类型推导规则是与常规引用完全不同的，当param被声明为通用引用时，T也会带上引用性。也就是说当通用引用被使用时，类型推导会区分左值实参和右值实参，但是对非通用引用时不会区分。</p><h3 id="当ParamType既不是指针也不是引用"><a href="#当ParamType既不是指针也不是引用" class="headerlink" title="当ParamType既不是指针也不是引用"></a>当ParamType既不是指针也不是引用</h3><p>这种情况即是我们的函数进行按值传递的时候，也就是每次都会拷贝我们所传进来的实参。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板声明部分</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"><span class="comment">//变量声明</span></span><br><span class="line"><span class="type">int</span> x=<span class="number">27</span>;                       <span class="comment">//x是int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> cx=x;                 <span class="comment">//cx是const int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rx=x;                <span class="comment">//rx是指向作为const int的x的引用</span></span><br><span class="line"><span class="comment">//调用部分</span></span><br><span class="line"><span class="built_in">f</span>(x);                           <span class="comment">//T和param的类型都是int</span></span><br><span class="line"><span class="built_in">f</span>(cx);                          <span class="comment">//T和param的类型都是int</span></span><br><span class="line"><span class="built_in">f</span>(rx);                          <span class="comment">//T和param的类型都是int</span></span><br></pre></td></tr></table></figure><br>在这种情况下，T和param都会完全忽略传进来的实参的引用性和常量性，因为拷贝出来的对象的特性已经完全不受原来实参的影响了。</p><h2 id="auto的类型推导"><a href="#auto的类型推导" class="headerlink" title="auto的类型推导"></a>auto的类型推导</h2><p>auto的类型推导其实与模板类型中T的推导大同小异，并且只在一个情况下会出现不同的推导。那就是当我们使用统一初始化（<strong>uniform initialization</strong>）时。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = <span class="number">27</span>;                   <span class="comment">//类型是int，值是27</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x2</span><span class="params">(<span class="number">27</span>)</span></span>;                    <span class="comment">//同上</span></span><br><span class="line"><span class="keyword">auto</span> x3 = &#123; <span class="number">27</span> &#125;;               <span class="comment">//类型是std::initializer_list&lt;int&gt;，</span></span><br><span class="line">                                <span class="comment">//值是&#123; 27 &#125;</span></span><br><span class="line"><span class="keyword">auto</span> x4&#123; <span class="number">27</span> &#125;;                  <span class="comment">//同上</span></span><br></pre></td></tr></table></figure><br>在上述的情形下，auto都可以像常见模板中的T那样被推导出来类型，但以下会出现一种情况，auto可以被推导出来，但是在模板中无法推导出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = &#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;;         <span class="comment">//x的类型是std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;            <span class="comment">//带有与x的声明等价的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;                <span class="comment">//形参声明的模板</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(&#123; <span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span> &#125;);               <span class="comment">//错误！不能推导出T</span></span><br></pre></td></tr></table></figure><p>这是因为auto类型推导假定花括号表示std::initializer_list而模板类型推导并不会这么做。 并且还有一点值得注意，C++14中auto可以被用在函数的返回值以及lambda的形参说明中，但是auto在这里所使用的推导规则是模板类型推导。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://github.com/CnTransGroup/EffectiveModernCppChinese">Effective Modern C++ 翻译</a></p>]]></content>
      
      
      <categories>
          
          <category> Programming Languages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>派生类虚函数调用父类虚函数的正确实践</title>
      <link href="/2023/02/25/%E6%B4%BE%E7%94%9F%E7%B1%BB%E8%99%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/02/25/%E6%B4%BE%E7%94%9F%E7%B1%BB%E8%99%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="简单背景描述"><a href="#简单背景描述" class="headerlink" title="简单背景描述"></a>简单背景描述</h2><p>这个问题是我在阅读Effective C++条例27中所涉及到一个小知识点，其主要是在关注当我们需要在派生类的虚函数中调用对应的父类虚函数时，我们的一些不恰当转型(cast)操作可能会让我们的当前派生类对象进入一种”伤残状态”，即派生类的基类数据部分没有如我们所想的发生改变，而是只改变了其派生类的成员数据。当然这么说有点过于抽象，我还是在下面贴出实际代码来解释一下吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;format&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_base;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> base) :<span class="built_in">m_base</span>(base) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_base = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetBase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_base;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_derived;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> base, <span class="type">int</span> derived): <span class="built_in">Base</span>(base), <span class="built_in">m_derived</span>(derived) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Resize</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Base::resize();</span></span><br><span class="line">        <span class="built_in">static_cast</span>&lt;Base&gt;(*<span class="keyword">this</span>).<span class="built_in">Resize</span>();</span><br><span class="line">        m_derived = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; format(<span class="string">&quot;Base part is &#123;&#125;, Derived part is &#123;&#125;!&quot;</span>, <span class="built_in">GetBase</span>(), m_derived); <span class="comment">//c++20新特性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    d.<span class="built_in">Resize</span>();</span><br><span class="line">    d.<span class="built_in">Print</span>(); <span class="comment">// 实际上会输出 Base part is 0, Derived part is -1! 这并不是我们想要的！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上述代码里，我们在Derived类中的resize方法里调用了Base类的对应方法，我们希望通过这样操作来同时改变一个派生类对象的基类成员数据和派生类成员数据，即我们希望通过上述代码的操作来把m_base和m_derived都置为-1。</p><p>但是遗憾的是，上述代码虽然看起来很有道理，我们将*this通过static_cast转为基类对象，并调用基类的resize函数来改变对应的基类成员数据，但是实际上编译器会拷贝一个*this的副本，并且在副本上进行操作，这也就导致实际上我们实际上改变的是一个拷贝的Derived对象的基类成员，而不是改变的实际的Derived对象。所以上述代码的输出是<strong>Base part is 0, Derived part is -1!</strong> 只有将上述代码中的cast操作换为注释掉的<code>Base::resize()</code>,我们才能得到想要的输出，也即是<strong>Base part is -1, Derived part is -1!</strong></p><p><strong>PS</strong>: 不过这种情况下其实是不是把基类的成员定义为protected更合理些, 毕竟这个关键字就是为了让子类访问父类成员变量而设计的。</p>]]></content>
      
      
      <categories>
          
          <category> Programming Languages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用xmake以及vscode配置vulkan的开发环境</title>
      <link href="/2023/02/24/Vscode%E4%B8%8B%E9%85%8D%E7%BD%AEshader%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83/"/>
      <url>/2023/02/24/Vscode%E4%B8%8B%E9%85%8D%E7%BD%AEshader%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么xmake是神"><a href="#为什么xmake是神" class="headerlink" title="为什么xmake是神"></a>为什么xmake是神</h2><p>做过C++开发的人员一定或多或少都被C++的编译流程折磨过，首先编译慢这个老生常态的问题就不提了，希望C++20的module能够快快普及开来，减少开发人员的时间负担(我好想<code>import std</code>啊，呜呜)。更为离谱的是，长久以来c++的社区都缺乏一个真正高效的统一构建工具，能够负责从第三方库管理一直到项目文件生成，然而这点隔壁的Rust做的就很好，Cargo永远的神。</p><p>所以本来我以为这辈子的C++生活可能就这样了，windows上用msbuild，然后跨平台用camke写写脚本，再配合上ninja之类的构建工具来生成项目文件。但是直到有一天我水知乎的时候发现有很多人都在推荐xmake这款构建工具，说其既可以管理第三方库，又可以进行项目文件生成。我遂尝试了一番，结果发现，<strong>嘿，真香！</strong></p><p>故在这里贴上<a href="https://xmake.io/#/">xmake</a>的地址，希望大家有机会可以去试一下，真的很不错！<del>而且还是国产的</del>。</p><p>至于我的具体配置其实是从<a href="https://zhuanlan.zhihu.com/p/495864590">麦老师</a>这里学习而来，是clang-cl + xmake + vscode。</p><h2 id="vulkan环境的配置"><a href="#vulkan环境的配置" class="headerlink" title="vulkan环境的配置"></a>vulkan环境的配置</h2><p>在有了xmake之后，我们可以写出一个非常简单的配置文件，我这里给出我的作为参考。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">add_requires(<span class="string">&quot;glm&quot;</span>, <span class="string">&quot;glfw&quot;</span>, <span class="string">&quot;glad&quot;</span>, <span class="string">&quot;vulkansdk&quot;</span>)</span><br><span class="line"></span><br><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line">add_includedirs(<span class="string">&quot;source/&quot;</span>)</span><br><span class="line">set_languages(<span class="string">&quot;cxx20&quot;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;runtime&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;static&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;source/runtime/**.cpp&quot;</span>)</span><br><span class="line">    add_packages(<span class="string">&quot;glfw&quot;</span>, <span class="string">&quot;glad&quot;</span>, <span class="string">&quot;vulkansdk&quot;</span>)</span><br><span class="line">    </span><br><span class="line">target(<span class="string">&quot;engine&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>) </span><br><span class="line">    add_files(<span class="string">&quot;source/*.cpp&quot;</span>)</span><br><span class="line">    add_packages(<span class="string">&quot;glfw&quot;</span>, <span class="string">&quot;glad&quot;</span>, <span class="string">&quot;vulkansdk&quot;</span>)</span><br><span class="line">    add_deps(<span class="string">&quot;runtime&quot;</span>)</span><br></pre></td></tr></table></figure><p>在<code>add_requires</code>这里我们写入了需要的第三方库，xmake在构建的时候会利用其自己管理的xrepo来自动下载，不用我们进行手动管理。</p><p>至于shader环境的配置，我们可以通过下面两款插件来完成。</p><ul><li><p>Shader languages support for VS Code (用来做语法高亮)</p></li><li><p>GLSL Linter (语法检查)</p></li></ul><p>glsl的代码补全我们则可以通过该<a href="https://gist.github.com/lewislepton/8b17f56baa7f1790a70284e7520f9623">地址</a>中json文件来进行配置，在上面的步骤都完成之后，你便拥有了一个可以自动进行glsl补全，并且可以安全的管理c++的第三方库的开发环境，实乃美事。</p><h2 id="剩下的工作"><a href="#剩下的工作" class="headerlink" title="剩下的工作"></a>剩下的工作</h2><p>环境配完了，剩下的就是直面可怕的vulkan了，虽然有点图形基础，但是还是被vulkan这琐碎的细节惊到了，真的就是差把我自己接在显卡上人脑操作了，但是还得学啊，毕竟还是想爽一爽新时代的图形api的！😋</p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现std::move和std::forward</title>
      <link href="/2023/02/13/%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0std-move%E4%BB%A5%E5%8F%8Astd-forward/"/>
      <url>/2023/02/13/%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0std-move%E4%BB%A5%E5%8F%8Astd-forward/</url>
      
        <content type="html"><![CDATA[<h2 id="你所需要的基础知识"><a href="#你所需要的基础知识" class="headerlink" title="你所需要的基础知识"></a>你所需要的基础知识</h2><h3 id="通用引用和右值引用"><a href="#通用引用和右值引用" class="headerlink" title="通用引用和右值引用"></a>通用引用和右值引用</h3><p>在实现<code>std::move()</code>以及<code>std::forward()</code>前，我们要对<strong>通用引用</strong>以及<strong>右值引用</strong>之间做一个基本的了解。一般来讲，当我们见到<code>&amp;&amp;</code>的时候，我们都会认为这是个右值引用，是用来绑定到右值上一个引用类型。但是如果这种情况出现模板参数的推导时，事情就会发生变化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; param &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种情况如果在不知道<strong>通用引用</strong>的情况下，我们会认为这个函数的参数只能绑定到右值上，因为很明显，<code>&amp;&amp;</code>代表的是右值引用。但是实际上下面的两个调用都可以通过编译并且给出运行结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string value = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="built_in">Func</span>(value);</span><br><span class="line"><span class="built_in">Func</span>(std::<span class="built_in">move</span>(value));</span><br></pre></td></tr></table></figure><p>也就是说神奇的事情发生了，<code>Func</code>即接受左值，又接收右值，通常来讲我们只会在<code>const&amp;</code>上看到这种情况，但是这里居然也发生了相同的事情。要想理解这种行为，我们就不得不了解一个全新的知识点，也就是<strong>引用折叠(reference collapsing)</strong>。</p><h3 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h3><p>我们知道，在C++里面，我们是没有办法声明<strong>引用的引用</strong>的，因为引用实际上是另一个变量的别名，是一种指针的语法糖。要是按照权威的书籍解释的话，也就是C++ primer中所述的</p><blockquote><p>因为引用本身不是一个对象，所以不能定义引用的引用。</p></blockquote><p>不过话虽然是这么说，但是实际上编译器不得不处理这种情况。例如上面的<code>Func(value)</code>，实际上如果进行展开的话，编译器会看到这么一个东西。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(string&amp; &amp;&amp;param)</span></span>;</span><br></pre></td></tr></table></figure><p>这里先忽略掉为什么<code>T</code>为什么会被推导为<code>string&amp;</code>(感兴趣的话可以去看看effective modern C++)，我们可以看到在类型推导中出现了左值引用的右值引用。但是又因为是没有引用的引用这一说法，所以编译器就会做一点手脚，来确保程序可以运行下去，而所做的这一手脚也就是所谓的引用折叠。其规则如下：</p><blockquote><p>发生引用的引用情况下，如果任一引用为左值引用，那么结果是左值引用，否则就是右值引用。</p></blockquote><p>好，当我们记住这个之后，我们就可以来实现<code>std::move()</code>以及<code>std::forward()</code>了。</p><h2 id="GO-来进行具体实现吧"><a href="#GO-来进行具体实现吧" class="headerlink" title="GO! 来进行具体实现吧"></a>GO! 来进行具体实现吧</h2><h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move()"></a>std::move()</h3><p><code>std::move()</code>所做的事情很简单，就是不管传进来的是什么东西，我都把它给转成右值引用。这个的实现并不需要我们之前所讲的引用折叠。其实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">move</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> returnType = std::<span class="type">remove_reference_t</span>&lt;T&gt;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;returnType&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到就是利用<code>std::remove_reference</code>把参数本身的引用性去了，然后将值类型<code>static_cast</code>到具体的右值引用。</p><h3 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward()"></a>std::forward()</h3><p><code>std::forward()</code>做的事就有点不一样了，它可以看作一个有选择的<code>std::move()</code>, 常用于函数参数的转发中。因为虽然我们平时嘴上喊着左值引用，右值引用什么的，<strong>但实际上，无论什么参数，它都是左值，而这些引用绑定到左值上还是右值上，与它们本身是左值毫无关系</strong>。所以为了保证其能够保持所谓的左值性与右值性，我们才需要<code>std::forward()</code>函数。</p><p>它的行为具体表现为，一个函数的实参要是被右值初始化，那么我们就把对应的参数转化为右值引用。代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(std::<span class="type">remove_reference_t</span>&lt;T&gt;&amp; parms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(parms);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到与<code>std::move()</code>的不同就是最后在<code>static_cast</code>的时候，<code>std::forward()</code>接受的参数是<code>T&amp;&amp;</code>，这样的话，通过引用折叠，我们就可以将参数完美的转发出去。</p><p>还是用上面的<code>Func(value)</code>和<code>Func(std::move(value))</code>来进行举例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Func</span>(value)-&gt; T==string&amp; -&gt; <span class="keyword">static_cast</span>&lt;string&amp; &amp;&amp;&gt; -&gt; 折叠! -&gt; <span class="keyword">static_cast</span>&lt;string&amp;&gt; 大功告成，传进来左值，转化到左值!</span><br><span class="line"><span class="built_in">Func</span>(value)-&gt; T==string -&gt; <span class="keyword">static_cast</span>&lt;string&amp;&amp;&gt; 大功告成，传进来右值，转化到右值!</span><br></pre></td></tr></table></figure><p>这里<code>T</code>的推导规则要是不懂的话，还是推荐之前的effective modern c++，里面把规则说的很明白了。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><p><a href="https://cntransgroup.github.io/EffectiveModernCppChinese/5.RRefMovSemPerfForw/item28.html">Item 28:理解引用折叠 - Effective Modern C++ </a></p></li><li><p><a href="https://cntransgroup.github.io/EffectiveModernCppChinese/1.DeducingTypes/item1.html">Item 1:理解模板类型推导 - Effective Modern C++ </a></p></li><li><p><a href="https://cntransgroup.github.io/EffectiveModernCppChinese/5.RRefMovSemPerfForw/item23.html">Item 23:理解std::move和std::forward - Effective Modern C++</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Programming Languages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>场景加速结构</title>
      <link href="/2023/02/02/%E5%9C%BA%E6%99%AF%E5%8A%A0%E9%80%9F%E7%BB%93%E6%9E%84/"/>
      <url>/2023/02/02/%E5%9C%BA%E6%99%AF%E5%8A%A0%E9%80%9F%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="场景加速结构"><a href="#场景加速结构" class="headerlink" title="场景加速结构"></a>场景加速结构</h2><p>在游戏引擎中，如何高效的管理游戏场景物体是一个非常重要的话题，在执行碰撞检测或者光线追踪求交时，如果我们每帧都要进行暴力检测的话，毫无疑问或造成非常多的计算资源浪费。于是为了解决这些问题，我们在构建世界的时候，往往会利用一些<strong>场景加速结构(Acceleration Structure)</strong>来管理。</p><p>常规的场景加速机构的主要思路是，我们利用一些空间信息或者物体位置来对物体进行树形划分，每个子节点管理一批物体，这样的话在查询的时候，我们就不用遍历整个场景，而是可以做<strong>到亚线性(Sublinear)</strong>的速度。</p><p>总的来看，场景划分的方法可以分为两大类，一种是基于空间的算法(<strong>Spatial Partition</strong>)，一种是基于物体的划分(<strong>Object Partition</strong>)。</p><h3 id="Spatial-Partition"><a href="#Spatial-Partition" class="headerlink" title="Spatial Partition"></a>Spatial Partition</h3><div align="center">    <img src="https://s2.loli.net/2023/02/08/L1NCQ3Zku8gF9Gf.png" width="85%" height="85%"></div><ul><li><strong>Oct-Tree</strong>: 通常成为八叉树，和二叉树其实本质上并不区别，每次将空间划分为8个区域，并且在有物体的地方继续进行递归。</li><li><strong>KD-Tree</strong>: KDTree和八叉树的区别是在于KDTree交替选择空间的三个轴进行切分，然后分成两块，而不是像八叉树沿着三个轴划分为8份。</li><li><strong>BSP-Tree</strong>: 和KD-Tree有点像，区别在于并不会交替的选择轴，而是真的随机将空间的划分为正半空间以及负半空间，这种方法很容易将空间划分出斜的空间，这种空间不太方便计算交点，所以目前用的很少。</li></ul><p>在虚幻引擎中，我们可以<code>Engine\Source\Runtime\Engine\Public\GenericOctree.h</code>找到对应的八叉树实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** An octree. */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ElementType,<span class="keyword">typename</span> OctreeSemantics&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TOctree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> TArray&lt;ElementType, <span class="keyword">typename</span> OctreeSemantics::ElementAllocator&gt; ElementArrayType;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> ElementArrayType::TConstIterator ElementConstIt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** A node in the octree. ============================== */</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FNode</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">TOctree</span>;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">FNode</span><span class="params">(<span class="type">const</span> FNode* InParent)</span></span>;</span><br><span class="line">        ~<span class="built_in">FNode</span>();</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">mutable</span> ElementArrayType Elements;</span><br><span class="line">        <span class="type">const</span> FNode* Parent;</span><br><span class="line">        <span class="keyword">mutable</span> FNode* Children[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">mutable</span> uint32 InclusiveNumElements : <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">mutable</span> uint32 bIsLeaf : <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/** A node in the octree. ============================== */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** An octree node iterator. =========================== */</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> StackAllocator = DefaultStackAllocator&gt;</span><br><span class="line">    <span class="keyword">class</span> TConstIterator</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">void</span> <span class="built_in">PushChild</span>(FOctreeChildNodeRef ChildRef);</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Advance</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">HasPendingNodes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        FNodeReference CurrentNode;</span><br><span class="line">        TArray&lt;FNodeReference,StackAllocator&gt; NodeStack;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/** An octree node iterator. =========================== */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddElement</span><span class="params">(<span class="keyword">typename</span> TTypeTraits&lt;ElementType&gt;::ConstInitType Element)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RemoveElement</span><span class="params">(FOctreeElementId ElementId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TOctree</span>(<span class="type">const</span> FVector&amp; InOrigin,<span class="type">float</span> InExtent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    FNode RootNode;</span><br><span class="line">    FOctreeNodeContext RootNodeContext;</span><br><span class="line">    <span class="type">float</span> MinLeafExtent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddElementToNode</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">typename</span> TTypeTraits&lt;ElementType&gt;::ConstInitType Element,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> FNode&amp; InNode,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> FOctreeNodeContext&amp; InContext</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Object-Partition"><a href="#Object-Partition" class="headerlink" title="Object Partition"></a>Object Partition</h3><p>在基于物体的划分中，其实主要就是讨论<strong>BVH(Bounding Volume Hierarchy)</strong>, 我的RayTracer中也实现了这个算法，确实是一个简单优秀的加速结构。</p><div align="center">    <img src="https://s2.loli.net/2023/02/08/xFXfrS2Pc9E4CDJ.png" width="85%" height="85%"></div><p>这种划分正如名字所说，将物体作为划分依据，这种划分算法的执行流程是按照物体的某个轴进行排序，然后将一定数量的物体归为一个组，然后在不断的递归下去，我的实现是如下所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;BvhNode&gt; <span class="title">Scene::BuildBVH</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>  axis        = Random::<span class="built_in">UInt</span>() % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">auto</span> compareFunc = (axis == <span class="number">0</span>) ? BoxCompareX : (axis == <span class="number">1</span>) ? BoxCompareY : BoxCompareZ;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;BvhNode&gt; root;</span><br><span class="line">    <span class="type">int</span> len = end - start; <span class="comment">// left open, right close</span></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">1</span>) &#123;</span><br><span class="line">        root-&gt;left = m_objects[start];</span><br><span class="line">        root-&gt;right = m_objects[end];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">compareFunc</span>(m_objects[start], m_objects[start + <span class="number">1</span>])) &#123;</span><br><span class="line">            root-&gt;left = m_objects[start];</span><br><span class="line">            root-&gt;right = m_objects[start + <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root-&gt;left = m_objects[start + <span class="number">1</span>];</span><br><span class="line">            root-&gt;right = m_objects[start];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(m_objects.<span class="built_in">begin</span>() + start, m_objects.<span class="built_in">begin</span>() + end, compareFunc);</span><br><span class="line">        <span class="type">int</span> mid = start + len / <span class="number">2</span>;</span><br><span class="line">        root-&gt;left = <span class="built_in">BuildBVH</span>(start, mid);</span><br><span class="line">        root-&gt;right = <span class="built_in">BuildBVH</span>(mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">    AABB leftBox, rightBox;</span><br><span class="line">    <span class="keyword">auto</span> left = root-&gt;left, right = root-&gt;right;</span><br><span class="line">    <span class="keyword">if</span>(!left-&gt;<span class="built_in">BoundingBox</span>(<span class="number">0</span>, <span class="number">0</span>, leftBox) || !right-&gt;<span class="built_in">BoundingBox</span>(<span class="number">0</span>, <span class="number">0</span>, rightBox)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Bounding box failed!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;box = <span class="built_in">SurroundingBox</span>(leftBox, rightBox);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法的好处是物体的划分的非常紧凑，相比于空间划分的方法更利于物体与光线的求交, 而且我个人是觉得也更好实现。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://www.bilibili.com/video/BV1X7411F744/?spm_id_from=333.337.search-card.all.click">GAMES101-现代计算机图形学入门</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Acceleration Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程下的缓存优化</title>
      <link href="/2023/01/31/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/"/>
      <url>/2023/01/31/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>在写Raytracer或者Rasterizer的时候，由于每个像素之间的计算是可以做到相互独立的，所以一个常见的优化便是开启多线程来进行加速，这样的话便不会说出现一核有难，多核围观的情况。但是，多线程启动后，我们需要额外关注对于全局状态的访问，并且尽可能的提高程序的cache友好性。</p><p>不过这次主要是对<a href="https://www.youtube.com/watch?v=1KTgc2SEt50&amp;t=1465s">Finding and Fixing Slow Code // Ray Tracing series</a>的一个记录，下面的代码是记录当光线击中物体时进行反射的一个情况，在测试的时候，发现<code>Random::vec3()</code>这个函数开销非常大，大概总时间的50%都是在算Random，这个说实话确实不太合理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ray.Origin = payload.WorldPosition + payload.WorldNormal * <span class="number">0.0001f</span>;</span><br><span class="line">ray.Direction = <span class="built_in">reflect</span>(ray.Direction, payload.WorldNormal + material.Roughness * Random::<span class="built_in">Vec3</span>(<span class="number">-0.5f</span>, <span class="number">0.5f</span>));</span><br></pre></td></tr></table></figure><div align="center">    <img src="https://s2.loli.net/2023/01/31/COgbNesYRh7JPU6.png" , width="70%" height="70%"></div><p>在找到重点问题后，我们便可以开始着手优化，这也就是所谓的<strong>benchmark first，then optimize</strong>。</p><p>并且记录下未优化情况下的render time, 大概是<strong>28ms</strong>左右</p><div align="center">    <img src="https://s2.loli.net/2023/01/31/ch5LlP6BWGKQs8g.png" , width="70%" height="70%"></div><h2 id="具体措施"><a href="#具体措施" class="headerlink" title="具体措施"></a>具体措施</h2><p>这个Random库的实现是非常简单的那一类，本身只是对<code>std::random</code>的一个简单封装，里面有一个<strong>random engine</strong>以及一个简单的<strong>std::uniform_int_distribution</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> std::mt19937 s_RandomEngine;</span><br><span class="line"><span class="type">static</span> std::uniform_int_distribution&lt;std::mt19937::result_type&gt; s_Distribution;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而我们所使用的这个<code>Random::Vec3()</code>的实现如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">float</span> <span class="title">Float</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">float</span>)<span class="built_in">s_Distribution</span>(s_RandomEngine) / (<span class="type">float</span>)std::numeric_limits&lt;<span class="type">uint32_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> glm::vec3 <span class="title">Vec3</span><span class="params">(<span class="type">float</span> min, <span class="type">float</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> glm::<span class="built_in">vec3</span>(<span class="built_in">Float</span>() * (max - min) + min, <span class="built_in">Float</span>() * (max - min) + min, <span class="built_in">Float</span>() * (max - min) + min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来看这个实现非常正常，并没有什么明显的性能缺陷。但是如果我们继续查看这个<strong>std::mt19937</strong>的实现的话，我们就可以发现在多线程下我们不能这么简单的使用这个算法，否则的话就会造成较大的性能损失。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_NODISCARD result_type <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_Idx == _Nx) &#123;</span><br><span class="line">            _Refill_upper();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span> * _Nx &lt;= <span class="keyword">this</span>-&gt;_Idx) &#123;</span><br><span class="line">            _Refill_lower();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _Ty _Res = <span class="keyword">this</span>-&gt;_Ax[<span class="keyword">this</span>-&gt;_Idx++] &amp; _WMSK;</span><br><span class="line">        _Res ^= (_Res &gt;&gt; _Ux) &amp; _Dxval;</span><br><span class="line">        _Res ^= (_Res &lt;&lt; _Sx) &amp; _Bx;</span><br><span class="line">        _Res ^= (_Res &lt;&lt; _Tx) &amp; _Cx;</span><br><span class="line">        _Res ^= (_Res &amp; _WMSK) &gt;&gt; _Lx;</span><br><span class="line">        <span class="keyword">return</span> _Res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在关键的<code>operator()</code>重载中，我们可以看到实际上<code>std::mt19937</code>是保存了一个内部状态，然后通过<code>this</code>指针以及index来进行访问。而这也就回到了我们一开始所说的，当多线程环境下，我们要注意对于全局状态的访问，当一堆线程疯狂的访问这个状态数组时，我们可以想到一定是一个cache miss地狱，在我的cpu，也就是intel的实现中，cpu的每个核共享l3 cache, 然后自己的l1, l2 cache是每个核所私有的。</p><p>于是一想，我们便会考虑到如果我们让每个核都私有这个状态数组那么会怎么样呢？这在C++也很容易尝试，我们将<strong>random engine</strong>声明如下，加上<strong>thread_local</strong>关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">thread_local</span> std::mt19937 s_RandomEngine;</span><br></pre></td></tr></table></figure><p>然后再次运行，我们看看结果如何</p><div>    <img src="https://s2.loli.net/2023/01/31/6oU48PDzGZNMtjy.png"></div><p>渲染时间从<strong>28ms</strong>左右下降到了<strong>11ms</strong>左右，也就是我们的假设的确是正确的，也证明了一开始的结论，我们必须要关注多线程下的访存优化，只有这样才能真正的利用好现代Cpu的多核架构。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://www.youtube.com/watch?v=1KTgc2SEt50&amp;t=1465s">Finding and Fixing Slow Code // Ray Tracing series</a></p>]]></content>
      
      
      <categories>
          
          <category> Optimization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Optimization </tag>
            
            <tag> Mutithread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>返回值优化(RVO, NRVO)</title>
      <link href="/2023/01/26/%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96-RVO-NRVO/"/>
      <url>/2023/01/26/%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96-RVO-NRVO/</url>
      
        <content type="html"><![CDATA[<h2 id="返回值优化"><a href="#返回值优化" class="headerlink" title="返回值优化"></a>返回值优化</h2><p>返回值优化在C++里面主要是通过<strong>RVO(Return Value Optimization)</strong>以及<strong>NVRO(Named Return Value Optimization)</strong>来完成。其中<strong>NVRO</strong>是在C++11中被引入，并且在C++17中作为强制要求。本质上是一种Copy Elision, 用来减少按<strong>值</strong>返回临时对象时所发生的拷贝。</p><p>具体来讲，我们分析下面这个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; t = <span class="built_in">func</span>();</span><br></pre></td></tr></table></figure><p>第一眼看上去，99%的人都会觉得这东西性能一定有大问题，毕竟直接返回了一个数组，那不得每次都得拷贝一大堆数据。但是实际上如果我们打开类似于<a href="https://cppinsights.io/">cpp insight</a>之类的分析工具，我们会看到以下代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>, std::allocator&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">func</span>()</span><br><span class="line">&#123;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>, std::allocator&lt;<span class="type">int</span>&gt; &gt; data = std::vector&lt;<span class="type">int</span>, std::allocator&lt;<span class="type">int</span>&gt; &gt;&#123;std::initializer_list&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, std::<span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;()&#125; <span class="comment">/* NRVO variable */</span>;</span><br><span class="line">  <span class="keyword">return</span> std::vector&lt;<span class="type">int</span>, std::allocator&lt;<span class="type">int</span>&gt; &gt;(<span class="keyword">static_cast</span>&lt;std::vector&lt;<span class="type">int</span>, std::allocator&lt;<span class="type">int</span>&gt;&gt;&amp;&amp;&gt;(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到编译器并没有像我们所想的那样傻傻的按值返回，而是做了对应的优化，编译器将临时变量作为右值引用来进行返回，从而避免了拷贝。并且cpp insight还给写了注释/<em> NRVO variable </em>/（可能你以为这注释是我写的，但是并不是😋）。</p><p>于是我们自然就想着去了解一下这个返回值优化到底是什么东西，然后当你google过后，你就会发现C++的返回值优化有两种类型，也就是开头所讲的<strong>RVO(Return Value Optimization)</strong>以及<strong>NVRO(Named Return Value Optimization)</strong>。</p><h3 id="RVO"><a href="#RVO" class="headerlink" title="RVO"></a>RVO</h3><p>让我们先了解下RVO吧，这个东西的官方解释如下：</p><blockquote><p>当一个未具名且未绑定到任何引用的临时变量被移动或复制到一个相同的对象时，拷贝和移动构造可以被省略。当这个临时对象在被构造的时候，他会直接被构造在将要拷贝/移动到的对象。当未命名临时对象是函数返回值时，发生的省略拷贝的行为被称为RVO(返回值优化)。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># obj is some custom class</span></span><br><span class="line"><span class="function">Obj <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Obj</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Obj obj = <span class="built_in">func</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种情况下，如果发生了RVO，我们就可以看到以下的等效代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># obj is some custom class</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Obj&amp; obj)</span> </span>&#123;</span><br><span class="line">  obj.Obj::<span class="built_in">Obj</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Obj obj; <span class="comment">// 并没有调用构造函数，是来自编译器的魔法</span></span><br><span class="line">  <span class="built_in">func</span>(obj);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原先的函数变成了一个void函数，然后我们将要赋值的变量通过参数传递进去，这样的话，我们就可以完成拷贝消除，也就是所谓的<strong>copy elision</strong>。</p><h3 id="NVRO"><a href="#NVRO" class="headerlink" title="NVRO"></a>NVRO</h3><p>顾名思义，这个优化主要是针对<strong>具名</strong>，也就是有名字的临时变量所进行的优化。而优化后的结果其实与上面RVO的并无大异。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># obj is some custom class</span></span><br><span class="line"><span class="function">Obj <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Obj <span class="title">temp</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// 区别就是有个具名的临时变量</span></span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Obj obj = <span class="built_in">func</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过在没有NVRO的编译器上面，<strong>上面这段代码如果执行RVO的话，实际上会多一次拷贝构造</strong>，这点要注意, 因为RVO会优化为以下代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Obj &amp;obj_)</span> </span>&#123;</span><br><span class="line">  <span class="function">Obj <span class="title">obj</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">  obj_.Obj::<span class="built_in">Obj</span>(obj); <span class="comment">// 拷贝构造函数</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化失效问题"><a href="#优化失效问题" class="headerlink" title="优化失效问题"></a>优化失效问题</h2><p>虽然返回值优化很棒，不禁让人感叹现代编译器的强大，但是还是存在一些特殊情况会阻碍这种优化的发生。</p><ol><li><p>函数中返回全局变量或者函数参数的情况下，优化不会发生。也就是说只要值不是在函数内创建，优化就不会发生。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Obj obj;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Obj obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>运行时依赖，也就是函数里面存在分支，编译器无法判断返回什么对象的情况下，优化也不会发生。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Obj <span class="title">fun</span><span class="params">(<span class="type">bool</span> flag)</span> </span>&#123;</span><br><span class="line">  Obj o1;</span><br><span class="line">  Obj o2;</span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    <span class="keyword">return</span> o1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Obj obj = <span class="built_in">fun</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>std::move()</code>的情况下，这个应该是重灾区，有很多人认为返回一个临时变量的右值引用就可以解决返回值优化，虽然这种做法看上去非常合理，但是实际上会强制调用移动构造函数，并且编译器优化上其实会隐式的帮你调用<code>std::move()</code>，所以自己是不用这么做的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Obj <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Obj obj;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">move</span>(obj); <span class="comment">// 不要这么做，会妨碍编译器优化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Obj obj = <span class="built_in">fun</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>返回值优化本身是非常有用的技术，能够大幅减少程序中的无用拷贝，在了解优化发生的时间以及禁忌事项后，我们可以非常高效的利用这个特性。但是另一方面其实把优化全都交给编译器也不太好，嗯，说到底还是自己做优化没准才是出路？</p>]]></content>
      
      
      <categories>
          
          <category> Optimization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Optimization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简易弹簧质点系统实现</title>
      <link href="/2023/01/25/%E7%AE%80%E6%98%93%E5%BC%B9%E7%B0%A7%E8%B4%A8%E7%82%B9%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/01/25/%E7%AE%80%E6%98%93%E5%BC%B9%E7%B0%A7%E8%B4%A8%E7%82%B9%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="弹簧质点系统-Mass-Spring-System"><a href="#弹簧质点系统-Mass-Spring-System" class="headerlink" title="弹簧质点系统(Mass-Spring System)"></a>弹簧质点系统(Mass-Spring System)</h2><p>弹簧质点系统算是最简单的一种物理模型，它假设所有物体除了<strong>质点</strong>，便是连接质点的<strong>弹簧</strong>。在这种情况下，我们需要分析的力非常简单，基本上只用考虑重力以及弹簧力即可。公式则如下图所示。</p><p>代码地址: <a href="https://github.com/WeebOwO/MassSpringSystem">https://github.com/WeebOwO/MassSpringSystem</a></p><div align="center">    <img src="https://s2.loli.net/2023/01/25/ZkyH75IRKopUBTr.png" width="70%" height="70%"></div><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>整体的结构如下面的伪代码所示，我们在主循环里面首先处理一下各种事件，然后物理引擎往前步进一段时间，最后提交给渲染器进行渲染。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main loop</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    process_event()</span><br><span class="line">    engine.step()</span><br><span class="line">    render()</span><br></pre></td></tr></table></figure><p>而具体到这个<code>engine.step()</code>函数，我们所做的事情则是计算每个点的受力，并根据受力计算出对应的速度，加速度，以及对应的位移。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># engine.step()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">step</span>():</span><br><span class="line">    calclate_force() <span class="comment"># 计算力</span></span><br><span class="line">    solve() <span class="comment"># 在这里求解各种各样的速度，并根据自定义delta time进行迭代</span></span><br></pre></td></tr></table></figure><p>从更为专业的术语上解释的话，我们其实是在各个离散的时间步长上进行物理量的累加，从而模拟连续世界中的积分。因为在实际物理世界中有加速度的存在，物体每个时间的速度都不相同，我们应该根据速度在时间的积分来得到真正的位移，但是计算机是无法做到所谓的<strong>“连续”</strong>的，所以我们进而采用了在每个细小时间步长上进行累加的做法。而这种模拟方法其实也有各种各样的流派，我们所使用的是较为简单的<strong>欧拉方法</strong>。</p><p>欧拉方法主要有三种流派</p><ol><li><p><strong>显式欧拉方法（explicit Euler method）</strong></p><script type="math/tex; mode=display">v(i+1) = v(i) + a(i)\Delta t \\</script><script type="math/tex; mode=display">v(i+1) = x(i) + v(i)\Delta t</script></li></ol><ol><li><p><strong>半隐式欧拉方法（semi-implicit Euler method）</strong>：</p><script type="math/tex; mode=display">v(i+1) = v(i) + a(i)\Delta t\\</script><script type="math/tex; mode=display">x(i+1) = x(i) + v(i+1)\Delta t</script></li></ol><ol><li><p><strong>隐式欧拉方法（implicit Euler method）</strong> ：</p><script type="math/tex; mode=display">v(i+1) = v(i) + a(i+1)\Delta t\\</script><script type="math/tex; mode=display">x(i+1) = x(i) + v(i+1)\Delta t</script></li></ol><p>我们在这里所使用的是<strong>半隐式欧拉方法（semi-implicit Euler method）</strong>来进行模拟，代码可以描述为如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># calclate_force</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(particle_num):</span><br><span class="line">            <span class="variable language_">self</span>.particle_force[i] = ti.Vector([<span class="number">0.0</span>, -gravity]) * <span class="variable language_">self</span>.particle_mass</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(particle_num):</span><br><span class="line">                <span class="keyword">if</span> <span class="variable language_">self</span>.rest_length[i, j] != <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># spring force i </span></span><br><span class="line">                    vec_ij = <span class="variable language_">self</span>.particle_pos[i] - <span class="variable language_">self</span>.particle_pos[j]</span><br><span class="line">                    direction = vec_ij.normalized()</span><br><span class="line">                    <span class="variable language_">self</span>.particle_force[i] += -<span class="variable language_">self</span>.young_modulus[<span class="literal">None</span>] * (vec_ij.norm() / <span class="variable language_">self</span>.rest_length[i, j] - <span class="number">1</span>) * direction</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sovle</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(particle_num):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.particle_fixed[i]:</span><br><span class="line">                <span class="variable language_">self</span>.particle_velocity[i] += <span class="variable language_">self</span>.delta_time * <span class="variable language_">self</span>.particle_force[i] / <span class="variable language_">self</span>.particle_mass</span><br><span class="line">                <span class="variable language_">self</span>.particle_velocity[i] *= ti.exp(-<span class="variable language_">self</span>.delta_time)</span><br><span class="line">                <span class="variable language_">self</span>.particle_pos[i] += <span class="variable language_">self</span>.particle_velocity[i] *<span class="variable language_">self</span>.delta_time</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="variable language_">self</span>.particle_velocity[i] = ti.Vector([<span class="number">0.0</span>, <span class="number">0.0</span>])</span><br></pre></td></tr></table></figure><p>在计算力的阶段，我们首先把当前所有的质点的力都假设为只有重力，然后再遍历其他的质点，如果发现两个质点有弹簧，那么我们就计算下当前质点所受到的弹簧力。而求解的话则是按照我们之前所讲的根据力来进行加速度，速度，以及位移的迭代。</p><p>最后的运行的效果如下图所示(可能加载的会有些慢，大概是1m左右的gif图)</p><div align="center">    <img src="https://s2.loli.net/2023/01/25/G3aIJVyDoClF278.gif" width="50%" height="50%"></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>弹簧质点系统本身的实现并不困难，但是看起来还是蛮有意思的，并且也能学习到物理引擎大体上是怎么个流程，也算是有点收获吧。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Physics </tag>
            
            <tag> Mass-Spring System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光线追踪中的辐射度量学</title>
      <link href="/2023/01/11/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E4%B8%AD%E7%9A%84%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/"/>
      <url>/2023/01/11/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E4%B8%AD%E7%9A%84%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要引入辐射度量学？"><a href="#为什么要引入辐射度量学？" class="headerlink" title="为什么要引入辐射度量学？"></a>为什么要引入辐射度量学？</h2><p>在传统的Whitted style ray tracing中，我们的Shading方法本质上还是一个基于经验公式的Phong或者Blinn-Phong光照模型，而并没有真正的基于物理去考虑光以及对应能量应该如何表述。所以为了能够使得Ray Tracer生成高质量图片，我们必须要借助一些成熟的数学物理体系来对光的能量进行描述。辐射度量学（Radiometry）便是一个非常理想的工具。</p><blockquote><p>Radiometry provides a set of ideas and mathematical tools to describe light propagation and reflection.  —Pbrtv3 5.4</p></blockquote><h2 id="相关单位定义与解释"><a href="#相关单位定义与解释" class="headerlink" title="相关单位定义与解释"></a>相关单位定义与解释</h2><p>首先引入一个最基本的关于辐射能量(<strong>Radiant Energy</strong>)的定义，我们用符号$Q[J=Joule]$来进行表述，他的单位则是我们自初中物理就非常熟悉的焦耳，不过在计算机图形领域，我们很少直接使用$Q$，因为这个能量很明显是和时间相关的一个量，一个物体接受光照的时间越长，其接受到的能量自然就越高。而在刨除了时间长短这影响后，我们才可以有效的衡量光源强度。而这也就是所谓的<strong>Radiant Power</strong>或<strong>Radiant Flux</strong>，数学定义如下。</p><script type="math/tex; mode=display">\Phi \equiv \frac{dQ}{dt} [W=Watt][lm=lumen]</script><p>在有了<strong>Radiant Power(后简写为Power)</strong>之后，我们便可以轻松的定义<strong>Radiant Intensity</strong>, <strong>Irradiance</strong>以及<strong>Radiance</strong>了。</p><p>不过在进行这些物理量的解释之前，我们还需要简单的了解下球面坐标系。</p><div align="center">    <img src="https://s2.loli.net/2023/01/13/d7RLXplsQ2cGJbf.png" width="40%" height="40%" alt="球面坐标系"></div><p>球面坐标系上的坐标是通过一个三元组$(r,\theta,\phi)$来确定，其中$r$代表到原点的距离，$\theta$代表与$y$轴的夹角，$\phi$代表与$x$轴的夹角。其与笛卡尔坐标系的转换其实也非常简单，公式如下:</p><script type="math/tex; mode=display">\begin{cases}x = r * cos(\phi)*sin(\theta)\\z = r * sin(\phi)*cos(\theta)\\y = r * cos(\theta)\\\end{cases}</script><p>使用球面坐标系的好处主要是方便我们更好的对光线进行建模，因为可以看到在球面坐标系中，我们更多的是基于角度(方向)而不是坐标值来进行考虑，这对于之后的理解毫无疑问是大有脾益的。</p><div align="center">    <img src="https://s2.loli.net/2023/01/14/6hq5QoacN47wsgP.png" width="50%" height="50%"></div><h3 id="Radiant-Intensity"><a href="#Radiant-Intensity" class="headerlink" title="Radiant Intensity"></a>Radiant Intensity</h3><p><strong>Radiant Instensity</strong>，从官方的定义来讲是<strong>Power per unit solid Angle</strong>，也就是在每个单位立体角方向上中所释放的功率。</p><script type="math/tex; mode=display">\begin{cases}I \equiv \frac {d\Phi} {d\omega} \\{d\omega}=sin\theta d\theta d\phi \\\end{cases}</script><p>立体角的定义其实可以类比弧度制中弧度的定义，其定义为球面上延申面积与半径平方的比值。</p><div align="center">    <img src="https://s2.loli.net/2023/01/14/EdyNBGJjkOX2inZ.png" width="70%," height="70%"></div>    <h3 id="Irradiance和Radiance"><a href="#Irradiance和Radiance" class="headerlink" title="Irradiance和Radiance"></a>Irradiance和Radiance</h3><p><strong>Irradiance</strong>则是定义为<strong>power per project area</strong>, 即</p><script type="math/tex; mode=display">E(x)\equiv\frac{d\Phi(x)}{dA}</script><p>这里$dA$代表的是面积，可以看到与<strong>Radiant Intensity</strong>的不同就是在于<strong>Intensity</strong>是定义在立体角上，而<strong>Irradiance</strong>是定义在面积之上。</p><p><strong>Radiance</strong>则可以是认为在<strong>Irradiance</strong>上进一步考虑每个立体角的贡献。也就是所谓的<strong>power per area per solid angle</strong>, 从数学上则定义为</p><script type="math/tex; mode=display">L(p, w) =\frac{d^2\Phi(p,w)}{d\omega dAcos\theta}</script><p>这里的$\theta$代表平面法线与当前立体角方向的夹角。</p><div align="center">    <img src="https://s2.loli.net/2023/01/14/ZW1ERTsBmUz43yP.png" width="50%" height="50%"></div><p>简单的看过来的话，<strong>Irradiance</strong>和<strong>Radiance</strong>的差别其实就是在于方向性，<strong>Radiance</strong>本质上可以看作<strong>Irradiance per unit solid angle</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来看，图形中的辐射度量学关键在于理解<strong>Irradiance</strong>和<strong>Radiance</strong>，这是构建PathTracer和渲染方程的基础，也是理解如何定量分析光照能量的关键。基于物理的渲染，一个最基本的要求便是能量守恒，所以说引入辐射度量学这套分析工具是十分有必要的。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><p><a href="https://www.bilibili.com/video/BV1X7411F744/?p=15&amp;spm_id_from=333.880.my_history.page.click&amp;vd_source=ea6df38502a795b7533aa33b78bf1159">Games101-现代计算机图形学入门</a></p></li><li><p><a href="https://www.pbr-book.org/3ed-2018/contents">Physically Based Rendering: From Theory to Implementation</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Raytracing </tag>
            
            <tag> Math </tag>
            
            <tag> Physics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unreal中的碰撞响应</title>
      <link href="/2022/12/30/Unreal%E4%B8%AD%E7%9A%84%E7%A2%B0%E6%92%9E%E5%93%8D%E5%BA%94/"/>
      <url>/2022/12/30/Unreal%E4%B8%AD%E7%9A%84%E7%A2%B0%E6%92%9E%E5%93%8D%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<h2 id="虚幻中的碰撞响应"><a href="#虚幻中的碰撞响应" class="headerlink" title="虚幻中的碰撞响应"></a>虚幻中的碰撞响应</h2><p>总的来看，虚幻中的碰撞响应可以分为两大类，即<strong>Object Response</strong>和<strong>Trace Response</strong>。其中<strong>Object Response</strong>就是我们常见的世界中物体与物体的之间的碰撞，而<strong>Trace Response</strong>则是指与<strong>LineTrace</strong>这类射线相应, 也就是决定该物体会不会响应场景中的射线检测。更进一步用官方文档的话来总结的话就是：</p><blockquote><p><strong>碰撞响应</strong>和<strong>追踪响应</strong>构成了虚幻引擎5在运行时处理碰撞和光线投射的基础。能够碰撞的每个对象都有<strong>对象类型</strong>和一系列响应，用来定义它与所有其他对象类型交互的方式。当碰撞或重叠事件发生时，涉及的两个（或全部）对象都会发出或受到阻挡、重叠或忽略的作用。</p><p><strong>追踪响应</strong> 的原理基本相同，唯一的区别是追踪（光线投射）本身可以定义为一种追踪响应类型，因此Actor可以根据<em>其</em>追踪响应阻挡或忽略。</p></blockquote><p>其中<strong>Object Response</strong>负责的交互类型如下：</p><ul><li><strong>WorldStatic</strong>: 应用于不移动的任意Actor。</li><li><strong>WorldDynamic</strong>: WorldDynamic用于受到动画或代码的影响而移动的Actor类型。</li><li><strong>Pawn</strong>：任何由玩家控制的实体的类型都应为Pawn。</li><li><strong>PhysicsBody</strong>：由于物理模拟而移动的任意Actor。</li><li><strong>Vehicle</strong>：载具的默认类型。</li><li><strong>Destructible</strong>：可破坏物网格体的默认类型。</li></ul><p><strong>Trace Response</strong>负责的话就只有<strong>Visibility</strong>和<strong>Camera</strong>。</p><p>在了解两大Response的具体负责类型之后，还要明白所谓的碰撞开启并不是说开关电灯那样，只有<strong>“亮”</strong>和<strong>“暗”</strong>两种状态。事实上我们伟大的虚幻引擎一共准备了4种状态。分别为</p><ul><li><strong>No Collision</strong>: 在物理引擎中此形体将不具有任何表示。不可用于空间查询（光线投射、Sweep、重叠）或模拟（刚体、约束）。此设置可提供最佳性能，尤其是对于移动对象。</li><li><strong>Query Only</strong>: 只能用来进行物理查询，例如是不是被射线击中了之类的，但是无法对物体进行物理模拟，比如我对这个物体施加了力，但是实际上并不参与物理计算。</li><li><strong>Physics Only</strong>：基本来说是上面的反方向，只进行物理上的模拟，<strong>不参与射线检测类的空间查询</strong>。</li><li><strong>Collision Enabled</strong>：我全都要</li></ul><p>在知道了碰撞开启的4种状态以及各种相应后，我们还可以对具体的某种相应类型做出特殊化，例如虚幻中<strong>Pown</strong>类的默认<strong>Response</strong>如下图所示：</p><div align="center"><img src="https://s2.loli.net/2022/12/30/uUR74DnHq29JowO.png"></div><p>这里的<strong>Ignore</strong>指的是完全不产生碰撞事件，<strong>Overlap</strong>是产生重叠事件(如果你开启了的话)，但是不会互相阻止对方通过，<strong>Block</strong>那自然就是直接把对方隔开，这里指的一提的是，当我们有A和B两个物体时，只有A block B 并且 B block A，两个物体才会发生<strong>Block</strong>。下图分别是<strong>Overlap</strong>与<strong>Block</strong>的具体图例(可能图会加载的有些慢)。</p><div align="center">    <img src="https://s2.loli.net/2022/12/30/qdzxMmPjwWD7iYH.png" alt="Overlap!!" width="75%," height="75%"></div><div align="center">    <img src="https://s2.loli.net/2022/12/30/OnEsrwuRGlhj9gy.png" alt="Block!!" width="75%," height="75%"></div><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://docs.unrealengine.com/5.0/zh-CN/collision-in-unreal-engine---overview/">虚幻引擎中的碰撞 | 虚幻引擎5.0文档 (unrealengine.com)</a></p><p><a href="https://docs.unrealengine.com/5.1/zh-CN/collision-response-reference-in-unreal-engine/">虚幻引擎中的碰撞响应参考 | 虚幻引擎5.1文档 (unrealengine.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Game Development </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Compile Loop！</title>
      <link href="/2022/12/22/%E7%BC%96%E8%AF%91%E6%97%B6%E5%BE%AA%E7%8E%AF/"/>
      <url>/2022/12/22/%E7%BC%96%E8%AF%91%E6%97%B6%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="编译时计算"><a href="#编译时计算" class="headerlink" title="编译时计算"></a>编译时计算</h2><p>C++的一大好处就是可以在编译时进行一些非常有意思的操作。虽然频繁的编译时计算会显著的增加编译时间，但是同样的也会减小运行时负担。当然前面这个只不过是一方面的说辞，我使用模板或者constexpr这些特性纯粹是因为这样看起来比较有趣。最近我就从<a href="https://www.youtube.com/watch?v=PahbNFypubE">Bisqwit</a>的一个视频中学到了一个将循环转到编译时的一个小技巧。故水个博客记录一下。</p><p>所有的测试代码可以在<a href="https://github.com/WeebOwO/CppTest/blob/main/TMP/compile_loop.cpp">这里</a>找到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> iter_times = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; iter_times; ++i) &#123;</span><br><span class="line">    <span class="built_in">do_something</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这段代码是一段稀松平常的循环，我们利用for语句进行了10次循环，每次循环都去执行<code>do_something()</code>这个函数。首先我们先考虑怎么把这个东西用编译时循环进行展开。我们所使用的到工具叫做<code>std::index_sequence</code>以及<code>std::make_index_sequence</code>，具体的代码如下所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> iter_times = <span class="number">10</span>;</span><br><span class="line">[&amp;]&lt;std::<span class="type">size_t</span>... p&gt;(std::index_sequence&lt;p...&gt;) &#123; (<span class="built_in">do_something</span>(p), ...); &#125;</span><br><span class="line">  (std::make_index_sequence&lt;iter_times&gt;&#123;&#125;);</span><br></pre></td></tr></table></figure><p><code>std::make_index_sequence&lt;iter_times&gt;</code>会产生<code>&#123;0, 1, 2, ..., iter_times - 1&#125;</code>的参数序列，我们再将其传入到函数参数之中，而又因为参数是可变的，所以我们自然要用可变模板参数来进行接收。在这之后，函数体内的<code>...</code>就会帮助我们进行展开，使其本质上转换为以下形式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do_something(0) op do_something(1) op do_something(2) ...</span><br></pre></td></tr></table></figure><p>而这里的op就是我们的逗号，所以上面的代码会转换为<code>do_something(0), do_something(1), do_something(2), ...</code>, 也就是说假如你的<code>do_something()</code>函数如果能返回一个可计算的值的话，这里的op也可以替换为*, +, /,等计算符号，使其能够进行结果计算，这种情况下其实我们利用的就是C++17的fold expression特性了。</p><p>原理就是如上所示，下面给出一段能运行的代码示例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Compile time loop test</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> iter_times = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">auto</span> do_something = [&amp;](<span class="type">size_t</span> i) &#123; std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">auto</span> do_another_thing = [&amp;](<span class="type">size_t</span> i) &#123; <span class="keyword">return</span> i; &#125;;</span><br><span class="line">  <span class="comment">// 普通循环</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; iter_times; ++i) &#123;</span><br><span class="line">    <span class="built_in">do_something</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line">  [&amp;]&lt;std::<span class="type">size_t</span>... p&gt;(std::index_sequence&lt;p...&gt;) &#123; (<span class="built_in">do_something</span>(p), ...); &#125;</span><br><span class="line">  (std::make_index_sequence&lt;iter_times&gt;&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更进一步！</span></span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line">  [&amp;]&lt;std::<span class="type">size_t</span>... p&gt;(std::index_sequence&lt;p...&gt;) &#123;</span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">do_another_thing</span>(p) + ...);</span><br><span class="line">  &#125;</span><br><span class="line">  (std::make_index_sequence&lt;iter_times&gt;&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>do_something()</code>中，我们就是简单的把每次传进来的循环变量进行输出，而<code>do_another_thing</code>,则是把结果直接返回，方便我们进行计算（因为更进一步中的操作是想办法把迭代序列下标进行求和）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">45</span><br></pre></td></tr></table></figure><p>可以看到我们完美的进行了循环转换。通过C++insight可以编译器形式的代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="comment">/*constexpr */</span> <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span>&lt;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&gt;<span class="params">(std::integer_sequence&lt;<span class="type">unsigned</span> <span class="type">long</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&gt;)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">     std::cout.<span class="keyword">operator</span>&lt;&lt;(do_another_thing.<span class="built_in">operator</span>()(<span class="number">0UL</span>) + (do_another_thing.<span class="built_in">operator</span>()(<span class="number">1UL</span>) + (do_another_thing.<span class="built_in">operator</span>()(<span class="number">2UL</span>) + (do_another_thing.<span class="built_in">operator</span>()(<span class="number">3UL</span>) + (do_another_thing.<span class="built_in">operator</span>()(<span class="number">4UL</span>) + (do_another_thing.<span class="built_in">operator</span>()(<span class="number">5UL</span>) + (do_another_thing.<span class="built_in">operator</span>()(<span class="number">6UL</span>) + (do_another_thing.<span class="built_in">operator</span>()(<span class="number">7UL</span>) + (do_another_thing.<span class="built_in">operator</span>()(<span class="number">8UL</span>) + do_another_thing.<span class="built_in">operator</span>()(<span class="number">9UL</span>))))))))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当你的结果不需要在运行时实时计算时，你可以试试利用这种模板元编程的技巧来将其转移到编译期，看起来还是非常cool并且非常有趣的，常规的for循环真的是已经写的麻木了。😋</p>]]></content>
      
      
      <categories>
          
          <category> TMP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Parallel Algorithms in STL</title>
      <link href="/2022/12/13/Parallel-Algorithms-in-STL/"/>
      <url>/2022/12/13/Parallel-Algorithms-in-STL/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>C++17引入了STL算法的并行化，作为一个Cpper，还是要小小的把玩一下，看看到底该怎么使用这个新特性，并且了解一下背后的实现原理。整体的测试代码可以在<a href="https://github.com/WeebOwO/CppTest">这里</a>找到。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>让我们以<code>std::sort</code>来作为一个小例子来介绍怎么将其并行化。</p><p>通常来讲如果要对一个序列进行排序的话，我们大概率会写出以下benchmark程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iterationCount; ++i) &#123;</span><br><span class="line">  <span class="comment">// testSize = 1&#x27;000&#x27;000;</span></span><br><span class="line">  <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">sorted</span><span class="params">(doubles)</span></span>;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> startTime = high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="built_in">sort</span>(sorted.<span class="built_in">begin</span>(), sorted.<span class="built_in">end</span>());</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> endTime = high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="built_in">print_results</span>(<span class="string">&quot;Serial&quot;</span>, sorted, startTime, endTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的sorted是利用随机数生成的一个浮点数序列，序列长度为100000，在我的机子上把优化全打开，进行5次测试，测试数据如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Testing with 1000000 doubles...</span><br><span class="line">Serial: Lowest: 1052 Highest: 4.29496e+09 Time: 76.077300ms</span><br><span class="line">Serial: Lowest: 1052 Highest: 4.29496e+09 Time: 76.480900ms</span><br><span class="line">Serial: Lowest: 1052 Highest: 4.29496e+09 Time: 77.995400ms</span><br><span class="line">Serial: Lowest: 1052 Highest: 4.29496e+09 Time: 76.134400ms</span><br><span class="line">Serial: Lowest: 1052 Highest: 4.29496e+09 Time: 75.936800ms</span><br></pre></td></tr></table></figure><p>整体时间大体是在75ms左右，看起来虽然还可以，但是当我们把它并行化之后，你会发现速度提升还是非常明显的。并行化的benchmark程序样例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iterationCount; ++i) &#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">sorted</span><span class="params">(doubles)</span></span>;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> startTime = high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// std::execution 并行化调用</span></span><br><span class="line">    <span class="built_in">sort</span>(std::execution::par_unseq, sorted.<span class="built_in">begin</span>(), sorted.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> endTime = high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">print_results</span>(<span class="string">&quot;Parallel&quot;</span>, sorted, startTime, endTime);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到唯一的区别在于<code>std::sort</code>多传入了一个参数<code>std::execution::par_unseq</code>，而这里的std::execution便是并行化的关键。该库文件下面主要是有4中并行化执行策略，分别为<code>sequenced_policy</code>,<code>parallel_policy</code>,<code>parallel_unsequenced_policy</code>,<code>unsequenced_policy</code>,其中前3个是C++17开始支持，第四个则是C++20开始支持。而我们这里所使用的<code>par_unseq</code>则是<code>parallel_unsequenced_policy</code>，其描述如下：</p><blockquote><p>以该执行策略类型为一种独有类型，对并行算法重载消歧义，并指示并行算法的执行可以并行化、向量化，或在线程间迁移（例如用亲窃取的调度器）。容许以此策略调用的并行算法中的元素访问函数调用在未指定线程中以无序方式执行，并相对于每个线程中的另一调用无顺序。</p></blockquote><p>这四种策略的不同可以在<a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t">cppreference</a>中查到。在并行化之后，我们以同样的测试标准进行测试，得到结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Testing with 1000000 doubles...</span><br><span class="line">Parallel: Lowest: 1850 Highest: 4.29497e+09 Time: 16.916000ms</span><br><span class="line">Parallel: Lowest: 1850 Highest: 4.29497e+09 Time: 16.415900ms</span><br><span class="line">Parallel: Lowest: 1850 Highest: 4.29497e+09 Time: 17.215400ms</span><br><span class="line">Parallel: Lowest: 1850 Highest: 4.29497e+09 Time: 18.038900ms</span><br><span class="line">Parallel: Lowest: 1850 Highest: 4.29497e+09 Time: 17.581000ms</span><br></pre></td></tr></table></figure><p>可以看到时间会下降到16ms左右，这个效率还是值得称赞的。不过这里面并没有做什么并发控制，也就是很容易出现一些问题，只有在做一些简单的数学运算，或者是彼此不会出现的竟态的操作之中，我们才可以使用这个并行化算法（感觉我在说废话）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体来看还是不错的，如果能确保数据访问在并行化时不会出问题的话，这些新算法的效率还是相当优秀的。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><p><a href="https://devblogs.microsoft.com/cppblog/using-c17-parallel-algorithms-for-better-performance/">Using C++17 Parallel Algorithms for Better Performance - C++ Team Blog (microsoft.com)</a></p></li><li><p><a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t">std::execution::sequenced_policy, std::execution::parallel_policy, std::execution::parallel_unsequenced_policy, std::execution::unsequenced_policy - cppreference.com</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Programming Languages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Concept!</title>
      <link href="/2022/12/05/concept/"/>
      <url>/2022/12/05/concept/</url>
      
        <content type="html"><![CDATA[<h2 id="Concept简介"><a href="#Concept简介" class="headerlink" title="Concept简介"></a>Concept简介</h2><p>谈及C++20，众多人都说这是能匹敌C++11的更新，而在20的众多更新中，Concept，Module，Corutine，Range被称为Big4，而今天文中主角便是Concept。</p><p>简单来说，Concept是用来限制模板中类型参数的一个语法糖，在C++20以前，如果我们想对模板参数的类型做一些限制，就得用一种叫做SFINAE的模板编程技巧，我对这个并没有太深入的理解，但是看到模板参数里面一段长长的enable_if，我还是深感其可怕。但是到了C++20，我们就可以有非常漂亮简洁的写法了(Concept：无所谓，我会出手)。</p><p>不过首先先推荐一下这个视频吧，算是我C++20的启蒙，<a href="https://www.youtube.com/watch?v=ImLFlLjSveM">How C++20 Changes the Way We Write Code</a>。下面所举的例子也是视频中的例子，你可以在<a href="https://github.com/WeebOwO/CppTest/blob/main/C%2B%2B20/concept.cpp">这里</a>找到我写的测试代码。</p><h2 id="关于Concept的一百种语法以及一个小例子"><a href="#关于Concept的一百种语法以及一个小例子" class="headerlink" title="关于Concept的一百种语法以及一个小例子"></a>关于Concept的一百种语法以及一个小例子</h2><p>先考虑这么一个需求，我们需要判断一个数是不是2的幂，我们可以写出以下代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_power_of_2</span><span class="params">(T target)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Integral part!\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> (target &gt; <span class="number">0</span>) &amp;&amp; (target &amp; (target - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是显而易见的一件事是位操作只对整数有效，假如我们想调用<code>is_power_of_2(0.25)</code>, 很明显就会出错。于是我们很自然的想去为浮点数也写一个实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_power_of_2</span><span class="params">(T target)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将浮点数分解为尾数和指数，然后查看尾数是不是0.5</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Float part!\n&quot;</span>;</span><br><span class="line">  <span class="type">int</span> exponent;</span><br><span class="line">  <span class="type">const</span> T mantissa = std::<span class="built_in">frexp</span>(target, &amp;exponent);</span><br><span class="line">  <span class="keyword">return</span> mantissa == <span class="built_in">T</span>(<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有一个问题在于，这明显是模板函数重定义，所以正常来讲我们应该把其更新为模板特化实现，并且这毫无问题，但是模板特化的问题在于一次只能特化一个类型，本质上感觉就是在给模板函数写函数重载一样，比如你给float得写一个，然后你还得给double再写一个，这明显不合理。而因为有了C++20，我们便可以利用Concept来实现整个过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">requires</span> std::integral&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_power_of_2</span><span class="params">(T target)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Integral part!\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> (target &gt; <span class="number">0</span>) &amp;&amp; (target &amp; (target - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">requires</span> std::floating_point&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_power_of_2</span><span class="params">(T target)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Float part!\n&quot;</span>;</span><br><span class="line">  <span class="type">int</span> exponent;</span><br><span class="line">  <span class="type">const</span> T mantissa = std::<span class="built_in">frexp</span>(target, &amp;exponent);</span><br><span class="line">  <span class="keyword">return</span> mantissa == <span class="built_in">T</span>(<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里requires子句来帮助我们完成了模板类型的检查，并且在报错的时候，这种写法的报错也会更加可读，而不是像以前的模板错误一样，一下子出来一大堆，生怕别人弄明白是怎么回事。这里的<code>std::integral</code>便是Concept，它定义了一种参数约束，如果你去看看源码的话，你就会发现其定义如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">concept</span> integral = is_integral_v&lt;_Ty&gt;;</span><br></pre></td></tr></table></figure><p>所以正如我之前所说，通过定义Concept，我们实际上是定义了一种模板参数中类型的“约束”，只有满足这个约束，我们才会去调用这个模板函数。定义完Concept之后，实际上我们有许多调用的方式，上面的requires子句其实只是其中一种。我们还可以将Concept直接塞到模板参数定义里面：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;std::integral T&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_power_of_2</span><span class="params">(T target)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Integral part!\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> (target &gt; <span class="number">0</span>) &amp;&amp; (target &amp; (target - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::floating_point T&gt; </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_power_of_2</span><span class="params">(T target)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Float part!\n&quot;</span>;</span><br><span class="line">  <span class="type">int</span> exponent;</span><br><span class="line">  <span class="type">const</span> T mantissa = std::<span class="built_in">frexp</span>(target, &amp;exponent);</span><br><span class="line">  <span class="keyword">return</span> mantissa == <span class="built_in">T</span>(<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更进一步，我们甚至可以做到模板声明都不用写，直接上伟大的auto</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_power_of_2</span><span class="params">(std::integral <span class="keyword">auto</span> target)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Integral part!\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> (target &gt; <span class="number">0</span>) &amp;&amp; (target &amp; (target - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_power_of_2</span><span class="params">(std::floating_point <span class="keyword">auto</span> target)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Float part!\n&quot;</span>;</span><br><span class="line">  <span class="type">int</span> exponent;</span><br><span class="line">  <span class="type">const</span> T mantissa = std::<span class="built_in">frexp</span>(target, &amp;exponent);</span><br><span class="line">  <span class="keyword">return</span> mantissa == <span class="built_in">T</span>(<span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Concept的组合"><a href="#Concept的组合" class="headerlink" title="Concept的组合"></a>Concept的组合</h2><p>正如之前所说，Concept是对模板参数进行约束，而方式则是对一个布尔表达式求值，所以很自然的Concept之间是可以进行组合的。例如下面这个例子，我们将算数类型定义为整数类型以及浮点数类型的混合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> arithmetic = std::integral&lt;T&gt; || std::floating_point&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">test_func</span><span class="params">(arithmetic <span class="keyword">auto</span> target)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Arithmetic part!\n&quot;</span>;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步，requires子句还可以拿来进行Concept的定义, 我们定义hashable类型为可以用来被std::hash所操作，并且返回一个可被转换为std::size_t的结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> hashable = <span class="built_in">requires</span>(T t) &#123;</span><br><span class="line">  &#123;std::hash&lt;T&gt;&#123;&#125;(t)&#125;-&gt;std::convertible_to&lt;std::<span class="type">size_t</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;hashable T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hash_map</span>;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我并不是模板编程的专家，但是Concept确实让我感觉是一个很大的进步，希望将来标准委员会能更新的快一点，不然我就真润去rust了。</p>]]></content>
      
      
      <categories>
          
          <category> Programming Languages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chandler Carruth Talk 总结</title>
      <link href="/2022/11/26/Chandler-Carruth-talk-%E6%80%BB%E7%BB%93/"/>
      <url>/2022/11/26/Chandler-Carruth-talk-%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Chandler Carruth算是我在CppCon上面最喜欢的一个老哥，他现在是在google的llvm组做编译器相关的工作，他的talk幽默风趣，并且喜欢说一些性能优化相关的东西，作为一个cpper，我是属于听见优化就走不动道的那类人，所以他的这些视频我都觉得收益良多。故尝试对他这几年在CppCon上的会议上的视频做一个简单的总结，顺便重新学习一下，毕竟常言道，温故而知新。（顺便一提，之前挺火的那个Carbon Language也是由他上台讲的）</p><h2 id="CppCon-2014-Efficiency-with-Algorithms-Performance-with-Data-Structures"><a href="#CppCon-2014-Efficiency-with-Algorithms-Performance-with-Data-Structures" class="headerlink" title="CppCon 2014 Efficiency with Algorithms, Performance with Data Structures"></a>CppCon 2014 Efficiency with Algorithms, Performance with Data Structures</h2><p>视频地址：<a href="https://www.youtube.com/watch?v=fHNmRkzxHWs&amp;t=1488s">https://www.youtube.com/watch?v=fHNmRkzxHWs&amp;t=1488s</a></p><p>这个演讲是他目前为止在CppCon上播放量最高的一期。其主旨主要是强调两点：</p><ul><li><strong>Efficiency with Algorithms</strong></li><li><strong>Performance with Data Structures</strong></li></ul><p>Carruth在这里把Efficiency解释如下：</p><blockquote><ol><li>Improving efficiency involves doing less work</li><li>An efficient program is one which does the minimum (that we’re aware of) amount of work to accomplish a given task</li></ol></blockquote><p>也就说从时间复杂度的角度来进行分析，对于具体任务来说，影响效率的唯一因素就是算法的时间复杂度。至于performance with Data Structures，则是表示在给定时间复杂度的情况下，我们如何更快的完成任务。例如遍历一个序列的话，我们最好用数组而不是链表来存储，在这个专题下其实讨论的主要是尽可能保证高的cache命中率，毕竟访问main memory还是有点慢的(点名批评了std::list，std::map，std::unordered_map以及其他关联性容器)。在这里其实Carruth还建议了用开放地址法来实现hashtable，而不是开链法。</p><p>并且这个talk其实还产出了一句我非常喜欢的话：</p><blockquote><p>C++ doesn’t give you perfomance, it gives you control over permormance</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CppCon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重新回归Hexo!</title>
      <link href="/2022/11/26/%E9%87%8D%E6%96%B0%E5%9B%9E%E5%BD%92Hexo/"/>
      <url>/2022/11/26/%E9%87%8D%E6%96%B0%E5%9B%9E%E5%BD%92Hexo/</url>
      
        <content type="html"><![CDATA[<p>在折腾了一天后，我从<a href="https://www.cnblogs.com/halftheworldaway">博客园</a>重新回归到Hexo之中，没想到用来用去还是这个简单的静态博客最适合我，并且这次我花了点软妹币买了一个5年份的域名，希望这点支出能成为接下来更新博客的动力。</p><p>总的来看，我的博客主要关注以下几个方面：</p><ul><li>游戏开发</li><li>个人项目以及学习记录</li><li>计算机基础知识</li><li>算法竞赛</li></ul><p>好，那第一篇博客就先<del>水</del>写到这里吧，加油啊我！！</p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
